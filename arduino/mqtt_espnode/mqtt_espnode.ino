#define DEBUG_ESPNODE

//#define RFID_MODE
//#define BTN_MODE

#define MULTI_SENSOR_MODE

//*****************************************************************************************************************//

#include "Arduino.h"

#include <EEPROM.h>
#include <ArduinoJson.h>
#include <WiFiManager.h>
#include <MQTTClient.h>

#ifdef ESP8266
#include <ESP8266WebServer.h>
#include <ESP8266HTTPUpdateServer.h>
#elif ESP32
#include <WebServer.h>
#include <HTTPUpdateServer.h>
#else
#error "Wrong board - ESP8266 or ESP32 must be used."
#endif

#ifdef RFID_MODE
#include <MFRC522.h>
#endif

#ifdef MULTI_SENSOR_MODE
#include <Wire.h>
#include <Adafruit_ADS1X15.h>
#include <MQUnifiedsensor.h>
#endif

//***** ESP Node *****//
const char fwName[16] = "mqtt_espnode";         //Name of the firmware
const char fwVersion[8] = "0.1";                // Version of the firmware
byte espMac[6];                                 // Byte array to store our MAC address

char nodeName[32] = "espnode";                  // Nodes name - default value, may be overridden
char uniqueNodeName[128] = "";                  // Unique node name, generated by combining node name and parts of the mac address
char configUser[32] = "admin";                  // User name for web access - default value, may be overridden
char configPassword[32] = "";                   // Password for web access - default value, may be overridden

//***** Config *****//
const unsigned long CONNECT_TO = 300;           // Timeout for WiFi and MQTT connection attempts in seconds
const unsigned long RECONNECT_TO = 15;          // Timeout for WiFi reconnection attempts in seconds
bool configShouldSave = false;                  // Flag indicating the configuration should be saved
const int CONFIG_SIZE = 10240;                  // Configuration size

//***** WebServer *****//
#ifdef ESP8266
ESP8266WebServer webServer(80);
ESP8266HTTPUpdateServer webUpdateServer;
#elif ESP32
WebServer webServer(80);
HTTPUpdateServer webUpdateServer;
#else
#error "Wrong board - ESP8266 or ESP32 must be used."
#endif

const char MASKED_PASSWORD[] = "********";

//***** MQTT *****//
const uint16_t MQTT_BUFFER = 4096;              // Size of buffer for incoming MQTT message
const unsigned long MQTT_RETRY_DELAY = 10000;   // Delay for reconnect
unsigned long mqttRetryMillis = 0;              // Timestamp used to measure delay for retry
WiFiClient mqttWifiClient;
MQTTClient mqttClient(MQTT_BUFFER);
char mqttServer[64] = "";                       // MQTT Server IP/URL - Default value, maybe overridden
char mqttPort[6] = "1883";                      // MQTT Server Port - Default value, maybe overridden
char mqttUser[32] = "";                         // MQTT User name - Default value, maybe overridden
char mqttPassword[32] = "";                     // MQTT Password - Default value, maybe overridden
char mqttTopic[128] = "";                       // MQTT Topic - Default value, maybe overridden
const char mqttDefaultTopicBase[16] = "espnodes/";    // MQTT Base for default topic
const char mqttAvailableSubTopic[16] = "available";   // MQTT available sub topic topic
boolean mqttAvailableMsgPending = false;              // MQTT flag indicating if availability status is pending

//***** RFID *****//
#ifdef RFID_MODE
#ifdef ESP8266
// RST=D3, SDA=D8, SCK=D5, MOSI=D7, MISO=D6
#define SS_PIN D8
#define RST_PIN D3
#elif ESP32
#error "Wrong board - ESP8266 must be used."   // "Wrong board - ESP8266 or ESP32 must be used."
#else
#error "Wrong board - ESP8266 must be used."   // "Wrong board - ESP8266 or ESP32 must be used."
#endif

MFRC522 rfid(SS_PIN, RST_PIN);
byte rfidNuidPICC[4];
String rfidNuidString;
String rfidControllerData;
unsigned long rfidLastReadMillis = 0;
const unsigned long RFID_CARD_READ_TIMEOUT = 5000;
bool rfidCardPending = false;
#endif

//***** MULTISENSOR *****//
#ifdef MULTI_SENSOR_MODE
Adafruit_ADS1115 multiAdc;               // ADC definition
#define MULTI_ADC_LIGHT_PIN 0            // ADC pin where light sensor is connected
#define MULTI_ADC_MQ_PIN 1               // ADC pin where MQ2 is connected
#define MULTI_ADC_VOLTAGE 5              // ADC voltage resolution
#define MULTI_ADC_RES 16                 // ADC resolution

bool multiAdcSensorInitialized = false;  // Bool holding the initialization state of the adc

#define MULTI_MQ_BOARD "ESP8266"            // Board definition
#define MULTI_MQ_TYPE "MQ2/ADS1115"         // MQ-Type definition
#define MULTI_MQ2_RATIO_CLEANAIR (9.83)     // MQ2 clean air ratio
#define MULTI_MQ2_WARMUP_SEC 20                 // MQ warmup time in sec

MQUnifiedsensor multiMqSensor(MULTI_MQ_BOARD, MULTI_ADC_VOLTAGE, MULTI_ADC_RES, -1, MULTI_MQ_TYPE);
unsigned long multiMqWarmupTimer = 0;       // Timestamp used to measure the warmup time
bool multiMqWarmedUp = false;               // Flag indicating that warmup has been done
bool multiMqCalibrated = false;             // Flag indicating that calibration has been done
String multiMqSensorState = "Initial";      // String holding the current state of the MQ sensor
int multiMqSmokeLimit = 500;                // Smoke limit in ppm - Default value, maybe overridden
bool multiMqSmokeFirstRead = true;          // Flag indicating if the reading for smoke is done foe the first time
bool multiMqSmokeDetected = false;          // Flag indicating if smoke was detected

long multiLightPercentage = -1;             // Long holding last read light percentage value

const uint8_t MULTI_MOTION_PIN = D0;         // Digital input for motion detection
bool multiMotionFirstRead = true;          // Flag indicating if the reading for motion is done foe the first time
bool multiMotionDetected = false;          // Flag indicating if motion was detected

#endif

//***** HTML Text - Root *****//
const char HTML_ROOT_SETTINGS[] PROGMEM = "<a href='/settings'><button>Settings</button></a>";
const char HTML_ROOT_MQTT[] PROGMEM = "<hr><a href='/mqtt'><button>MQTT</button></a>";
#ifdef RFID_MODE
const char HTML_ROOT_RFID[] PROGMEM = "<hr><a href='/rfid'><button>RFID</button></a>";
#endif
const char HTML_ROOT_STATUS[] PROGMEM = "<hr><a href='/status'><button>Status</button></a>";

//***** HTML Text - Setting *****//
const char HTML_SETTINGS_FORM_START[] PROGMEM = "<form method='POST' action='saveSettings'>";
const char HTML_SETTINGS_NODE_NAME[] PROGMEM = "<b>Node Name</b> <i><small>(required. lowercase letters, numbers, and _ only)</small></i><input id='nodeName' required name='nodeName' maxlength=31 placeholder='Node Name' pattern='[a-z0-9_]*' value='{nodeName}'>";
const char HTML_SETTINGS_WIFI_SSID[] PROGMEM = "<br/><br/><b>WiFi SSID</b> <i><small>(required)</small></i><input id='wifiSsid' required name='wifiSsid' maxlength=32 placeholder='WiFi SSID' value='{wifiSsid}'>";
const char HTML_SETTINGS_WIFI_PASSWD[] PROGMEM = "<br/><b>WiFi Password</b> <i><small>(optional)</small></i><input id='wifiPass' name='wifiPass' type='password' maxlength=64 placeholder='WiFi Password' value='{wifiPass}'>";
const char HTML_SETTINGS_ADMIN_USER[] PROGMEM = "<br/><br/><b>Admin Username</b> <i><small>(optional)</small></i><input id='configUser' name='configUser' maxlength=31 placeholder='Admin User' value='{configUser}'>";
const char HTML_SETTINGS_ADMIN_PASSWD[] PROGMEM = "<br/><b>Admin Password</b> <i><small>(optional)</small></i><input id='configPassword' name='configPassword' type='password' maxlength=31 placeholder='Admin User Password' value='{configPassword}'>";
const char HTML_SETTINGS_BTN_SAVE_FORM_END[] PROGMEM ="<br/><br/><button type='submit'>Save</button></form>";
const char HTML_SETTINGS_BTN_BACK[] PROGMEM ="<hr><a href='/'><button>Back</button></a>";

//***** HTML Text - SaveSetting *****//
const char HTML_SAVESETTINGS_SAVE[] PROGMEM = "<meta http-equiv='refresh' content='15;url=/' />";
const char HTML_SAVESETTINGS_SAVETEXT[] PROGMEM = "<br/>Saving updated configuration values and restarting device ... redirecting to <a href='/'>navigation</a>";
const char HTML_SAVESETTINGS_NOCHANGE[] PROGMEM = "<meta http-equiv='refresh' content='3;url=/' />";
const char HTML_SAVESETTINGS_NOCHANGETEXT[] PROGMEM = "<br/>No changes found ... redirecting to <a href='/'>navigation</a>";

//***** HTML Text - MQTT *****//
const char HTML_MQTT_FORM_START[] PROGMEM = "<form method='POST' action='saveMqtt'>";
const char HTML_MQTT_SERVER[] PROGMEM = "<br/><br/><b>MQTT Broker</b> <i><small>(required)</small></i><input id='mqttServer' required name='mqttServer' maxlength=63 placeholder='mqttServer' value='{mqttServer}'>";
const char HTML_MQTT_PORT[] PROGMEM = "<br/><b>MQTT Port</b> <i><small>(required)</small></i><input id='mqttPort' required name='mqttPort' type='number' maxlength=5 placeholder='mqttPort' value='{mqttPort}'>";
const char HTML_MQTT_USER[] PROGMEM = "<br/><b>MQTT User</b> <i><small>(optional)</small></i><input id='mqttUser' name='mqttUser' maxlength=31 placeholder='mqttUser' value='{mqttUser}'>";
const char HTML_MQTT_PASSWD[] PROGMEM = "<br/><b>MQTT Password</b> <i><small>(optional)</small></i><input id='mqttPassword' name='mqttPassword' type='password' maxlength=31 placeholder='mqttPassword' value='{mqttPassword}'>";
const char HTML_MQTT_TOPIC[] PROGMEM = "<br/><b>MQTT Topic</b> <i><small>(optional)</small></i><input id='mqttTopic' name='mqttTopic' maxlength=127 value='{mqttTopic}'>";
const char HTML_MQTT_STATUS[] PROGMEM ="<br/><b>MQTT Status</b><input id='mqttSatus' readonly name='mqttSatus' placeholder='mqttStatus' value='{mqttStatus}'>";
const char HTML_MQTT_BTN_SAVE_FORM_END[] PROGMEM ="<br/><br/><button type='submit'>Save</button></form>";
const char HTML_MQTT_BTN_BACK[] PROGMEM = "<hr><a href='/'><button>Back</button></a>";

//***** HTML Text - Status *****//
const char HTML_STATUS_FW_NAME[] PROGMEM = "<br/><b>FW Name: </b> {firmwareName}";
const char HTML_STATUS_FW_VERSION[] PROGMEM = "<br/><b>FW Name: </b> {firmwareVersion}";
const char HTML_STATUS_FW_FORM[] PROGMEM = "<form method='POST' action='/updateFw' enctype='multipart/form-data'> <hr> <b>FW Upload: </b> <input type='file' accept='.bin,.bin.gz' name='firmware'> <button>Update Firmware</button> </form> <hr>";
const char HTML_STATUS_CPU[] PROGMEM = "<br/><b>CPU Frequency: </b> {cpuFreq} MHz";
const char HTML_STATUS_SKETCH_SIZE[] PROGMEM = "<br/><b>Sketch Size: </b> {sketchSize} bytes";
const char HTML_STATUS_SKETCH_FREESIZE[] PROGMEM = "<br/><b>Free Sketch Space: </b> {freeSketchSize} bytes";
const char HTML_STATUS_HEAP[] PROGMEM = "<br/><b>Heap Free: </b> {freeHeap}";
const char HTML_STATUS_IPADDR[] PROGMEM = "<br/><b>IP Address: </b> {ipAddr}";
const char HTML_STATUS_SIGSTRENGTH[] PROGMEM = "<br/><b>Signal Strength: </b> {sigStrength}";
const char HTML_STATUS_UPTIME[] PROGMEM = "<br/><b>Uptime: </b> {uptime} sec";
const char HTML_STATUS_BTN_BACK[] PROGMEM = "<hr><a href='/'><button>Back</button></a>";

//***** HTML Text - RFID *****//
#ifdef RFID_MODE
const char HTML_RFID_STATUS[] PROGMEM = "<br/><b>RFID-Status: </b> {rfidControllerData}";
const char HTML_RFID_LASTNUID[] PROGMEM = "<br/><b>Last RFID: </b> {rfidNuidString}";
const char HTML_RFID_BTN_BACK[] PROGMEM = "<hr><a href='/'><button>Back</button></a>";
#endif

#ifdef MULTI_SENSOR_MODE
const char HTML_RFID_STATUS[] PROGMEM = "<br/><b>RFID-Status: </b> {rfidControllerData}";
const char HTML_RFID_LASTNUID[] PROGMEM = "<br/><b>Last RFID: </b> {rfidNuidString}";
const char HTML_RFID_BTN_BACK[] PROGMEM = "<hr><a href='/'><button>Back</button></a>";
#endif

//*****************************************************************************************************************//
void setup() {
    configRead();

    nodeSetup();

#ifdef DEBUG_ESPNODE
    debugSetup();
#endif

    wifiSetup();

    mqttSetup();

    webSetup();

#ifdef RFID_MODE
    rfidSetup();
#endif

#ifdef MULTI_SENSOR_MODE
    multiSetup();
#endif
}

//*****************************************************************************************************************//
void loop() {
    wifiLoop();

    mqttLoop();

    webLoop();

#ifdef RFID_MODE
    rfidLoop();
#endif

#ifdef MULTI_SENSOR_MODE
    multiLoop();
#endif
}

//*****************************************************************************************************************//

//***** Node Functions *****//
void nodeSetup() {
    WiFi.macAddress(espMac);            // Read our MAC address and save it to espMac

    String uniqueName = String(nodeName) + "-" + String(espMac[0], HEX) + String(espMac[1], HEX) + String(espMac[2], HEX) + String(espMac[3], HEX) + String(espMac[4], HEX) + String(espMac[5], HEX);
    strcpy(uniqueNodeName, uniqueName.c_str());
}

void nodeReset() {
#ifdef DEBUG_ESPNODE
    debugPrintln(F("RESET: reset"));
#endif

    mqttSendAvailable(true);
    delay(100);
    ESP.restart();
    delay(5000);
}

//***** Debug Functions ****//
#ifdef DEBUG_ESPNODE
void debugSetup() {
    Serial.begin(115200);
    Serial.println();
    Serial.println("********************************************");

    debugPrintln(String(F("SYSTEM: Starting ")) + String(uniqueNodeName) + String(F(" v")) + String(fwVersion));
}

void debugPrintln(String debugText) {
    String debugTimeText = "[+" + String(float(millis()) / 1000, 3) + "s] " + debugText;

    Serial.println(debugTimeText);
    Serial.flush();
}

void debugPrint(String debugText) {
    Serial.print(debugText);
    Serial.flush();
}
#endif

//***** Config Functions *****//
void configSaveCallback() {
    //Callback notifying of the need to save the configuration
#ifdef DEBUG_ESPNODE
    debugPrintln(F("Configuration changed, flagging for save"));
#endif
    configShouldSave = true;
}

void configRead() {
    // Read saved config.json from SPIFFS
#ifdef DEBUG_ESPNODE
    debugPrintln(F("SPIFFS: mounting SPIFFS"));
#endif

#ifdef ESP8266
    if (SPIFFS.begin()) {
#endif
#ifdef ESP32
    if (SPIFFS.begin(true)) {
#endif
        if (SPIFFS.exists("/config.json")) { // File exists, reading and loading

#ifdef DEBUG_ESPNODE
            debugPrintln(F("SPIFFS: reading /config.json"));
#endif
            File configFile = SPIFFS.open("/config.json", "r");
            if (configFile) {
                size_t configFileSize = configFile.size(); // Allocate a buffer to store contents of the file.
                std::unique_ptr<char[]> buf(new char[configFileSize]);
                configFile.readBytes(buf.get(), configFileSize);

                DynamicJsonDocument configJson(CONFIG_SIZE);
                DeserializationError jsonError = deserializeJson(configJson, buf.get());

                if (jsonError) { // Couldn't parse the saved config
#ifdef DEBUG_ESPNODE
                    debugPrintln(String(F("SPIFFS: [ERROR] Failed to parse /config.json: ")) + String(jsonError.c_str()));
#endif
                }
                else {
                    // Read node configuration
                    if (!configJson["nodeName"].isNull()) {
                        strcpy(nodeName, configJson["nodeName"]);
                    }
                    else {
                        strcpy(nodeName, configJson["nodeName"]);
                    }
                    if (!configJson["configUser"].isNull()) {
                        strcpy(configUser, configJson["configUser"]);
                    }
                    if (!configJson["configPassword"].isNull()) {
                        strcpy(configPassword, configJson["configPassword"]);
                    }

                    // Read MQTT configuration
                    if (!configJson["mqttServer"].isNull()) {
                        strcpy(mqttServer, configJson["mqttServer"]);
                    }
                    if (!configJson["mqttPort"].isNull()) {
                        strcpy(mqttPort, configJson["mqttPort"]);
                    }
                    if (!configJson["mqttUser"].isNull()) {
                        strcpy(mqttUser, configJson["mqttUser"]);
                    }
                    if (!configJson["mqttPassword"].isNull()) {
                        strcpy(mqttPassword, configJson["mqttPassword"]);
                    }
                    if (!configJson["mqttTopic"].isNull()) {
                        strcpy(mqttTopic, configJson["mqttTopic"]);
                    }

                    // Print read JSON configuration
                    String configJsonStr;
                    serializeJson(configJson, configJsonStr);
#ifdef DEBUG_ESPNODE
                    debugPrintln(String(F("SPIFFS: parsed json:")) + configJsonStr);
#endif
                }
            }
            else {
#ifdef DEBUG_ESPNODE
                debugPrintln(F("SPIFFS: [ERROR] Failed to read /config.json"));
#endif
            }
        }
        else {
#ifdef DEBUG_ESPNODE
            debugPrintln(F("SPIFFS: [WARNING] /config.json not found, will be created on first config save"));
#endif
        }
    }
    else {
#ifdef DEBUG_ESPNODE
        debugPrintln(F("SPIFFS: [ERROR] Failed to mount FS"));
#endif
    }
}

void configSave() { // Save the parameters to config.json
#ifdef DEBUG_ESPNODE
    debugPrintln(F("SPIFFS: Saving config"));
#endif
    DynamicJsonDocument jsonConfigValues(CONFIG_SIZE);

    // Save node configuration
    jsonConfigValues["nodeName"] = nodeName;
    jsonConfigValues["configUser"] = configUser;
    jsonConfigValues["configPassword"] = configPassword;

    // Save mqtt configuration
    jsonConfigValues["mqttServer"] = mqttServer;
    jsonConfigValues["mqttPort"] = mqttPort;
    jsonConfigValues["mqttUser"] = mqttUser;
    jsonConfigValues["mqttPassword"] = mqttPassword;
    jsonConfigValues["mqttTopic"] = mqttTopic;

    File configFile = SPIFFS.open("/config.json", "w");
    if (!configFile) {
#ifdef DEBUG_ESPNODE
        debugPrintln(F("SPIFFS: Failed to open config file for writing"));
#endif
    }
    else {
        serializeJson(jsonConfigValues, configFile);
        configFile.close();

        // Print saved JSON configuration
        String configJsonStr;
        serializeJson(jsonConfigValues, configJsonStr);
#ifdef DEBUG_ESPNODE
        debugPrintln(String(F("SPIFFS: saved json:")) + configJsonStr);
#endif
    }
    configShouldSave = false;
}

void configClear() { // Clear out all local storage
#ifdef DEBUG_ESPNODE
    debugPrintln(F("RESET: Formatting SPIFFS"));
#endif
    SPIFFS.format();

    wifiResetSettings();

    EEPROM.begin(512);
#ifdef DEBUG_ESPNODE
    debugPrintln(F("Clearing EEPROM..."));
#endif
    for (uint16_t i = 0; i < EEPROM.length(); i++) {
        EEPROM.write(i, 0);
    }
#ifdef DEBUG_ESPNODE
    debugPrintln(F("RESET: Rebooting device"));
#endif
    nodeReset();
}

//***** WiFi Functions ****//
void wifiResetSettings() {
#ifdef DEBUG_ESPNODE
    debugPrintln(F("WIFI: Clearing WiFi settings..."));
#endif
    WiFiManager wifiManager;
    wifiManager.resetSettings();
}

void wifiConfig(String wifiSsid, String wifiPass) {
#ifdef DEBUG_ESPNODE
    debugPrintln(String(F("WIFI: Changing to WiFi network")) + wifiSsid + String(F("|")) + wifiPass + String(F("...")));
#endif
    WiFi.begin(wifiSsid.c_str(), wifiPass.c_str());
}

void wifiSetup() {
    WiFiManager wifiManager;
    wifiManager.autoConnect(uniqueNodeName);
}

void wifiLoop() {
    while ((WiFi.status() != WL_CONNECTED) || (WiFi.localIP().toString() == "0.0.0.0")) {
        // Check WiFi is connected and that we have a valid IP, retry until we do.

        if (WiFi.status() == WL_CONNECTED) {
            // If we're currently connected, disconnect so we can try again
            WiFi.disconnect();
        }

        wifiSetup();
    }
}

//***** MQTT Functions *****//

void mqttSetup() {
    mqttClient.begin(mqttServer, atoi(mqttPort), mqttWifiClient);
    mqttConnect();
}

void mqttConnect() {
    // Connect initially or reconnect if connection was lost
    if (!mqttClient.connected()) {
        bool retry = false;

        //check for retry delay
        if (mqttRetryMillis > 0) {
            unsigned long millisPassed = millis() - mqttRetryMillis;
            retry = (millisPassed >= MQTT_RETRY_DELAY);
        }
        else {
            retry = true;
        }

        if (retry) {
            // Set keepAlive, cleanSession, timeout
            mqttClient.setOptions(30, true, 1000);

            mqttClient.connect(uniqueNodeName, mqttUser, mqttPassword);
            if (mqttClient.connected()) {
                mqttRetryMillis = 0;
                mqttAvailableMsgPending = true;
#ifdef DEBUG_ESPNODE
                debugPrintln(String(F("MQTT: Connection established to ")) + String(mqttServer));
#endif
            }
            else {
                mqttRetryMillis = millis();
#ifdef DEBUG_ESPNODE
                debugPrintln(String(F("MQTT: Connection could not be established - failed with rc ")) + String(mqttClient.returnCode()));
#endif
            }
        }
    }
}

String mqttGetDefaultTopic() {
    String topic = mqttDefaultTopicBase + String(uniqueNodeName);
    return topic;
}

String mqttGetNodeTopic(String subTopic) {
    String topic = mqttTopic;

    if (topic.isEmpty()) {
        topic = mqttGetDefaultTopic();
    }

    if (!subTopic.isEmpty()) {
        if (!subTopic.startsWith(F("/"))) {
            topic += F("/");
        }

        topic += subTopic;
    }

    return topic;
}

bool mqttSend(String topic, String cmd) {
    return mqttClient.publish(topic, cmd);
}

bool mqttSendAvailable(bool reset) {
    if (reset) {
#ifdef DEBUG_ESPNODE
        debugPrintln(String(F("MQTT: Preparing reset, sending available --> false.")) + String(mqttServer));
#endif

        return mqttSend(mqttGetNodeTopic(mqttAvailableSubTopic), String(F("false")));
    }

    if (mqttAvailableMsgPending) {

#ifdef DEBUG_ESPNODE
        debugPrintln(String(F("MQTT: Sending pending available state --> true.")));
#endif
        mqttAvailableMsgPending = !mqttSend(mqttGetNodeTopic(mqttAvailableSubTopic), String(F("true")));

#ifdef MULTI_SENSOR_MODE
#ifdef DEBUG_ESPNODE
        debugPrintln(String(F("MQTT: Sending limit for multi-sensor/smoke detector.")));
#endif

        mqttAvailableMsgPending = !mqttSend(mqttGetNodeTopic(String(F("smoke/limit"))), String(multiMqSmokeLimit));
#endif

        return true;
    }
    else {
        return false;
    }

    return true;
}

void mqttLoop() {
    mqttConnect();
    mqttSendAvailable(false);

    mqttClient.loop();
}

//***** WebServer Functions *****//
void webSetup() {
// Connect with http update server
    if ((configPassword[0] != '\0') && (configUser[0] != '\0')) {
        webUpdateServer.setup(&webServer, String(F("/updateFw")), String(configUser), String(configPassword));
    }
    else { // or without a password if not
        webUpdateServer.setup(&webServer, String(F("/updateFw")));
    }

// Setup webserver
    webServer.on("/", webHandleRoot);
    webServer.on("/settings", webHandleSettings);
    webServer.on("/saveSettings", webHandleSaveSettings);
    webServer.on("/mqtt", webHandleMqttSettings);
    webServer.on("/saveMqtt", webHandleMqttSaveSettings);
    webServer.on("/status", webHandleStatus);

#ifdef RFID_MODE
    webServer.on("/rfid", webHandleRfid);
#endif

    webServer.onNotFound(webHandleNotFound);
    webServer.begin();

#ifdef DEBUG_ESPNODE
    debugPrintln(String(F("HTTP: Server started @ http://")) + WiFi.localIP().toString());
#endif
}

void webCheckAuth() {
    if (configPassword[0] != '\0') {
        //Request HTTP auth if configPassword is set

        if (!webServer.authenticate(configUser, configPassword)) {
            return webServer.requestAuthentication();
        }
    }
}

void webStartHttpMsg(String type, String meta, int code) {
//check if auth is needed
    webCheckAuth();

// Prepare for multipart and send first part of html header
    String httpMessage = FPSTR(HTTP_HEADER);
    httpMessage.replace("{v}", String(uniqueNodeName));

    webServer.setContentLength(CONTENT_LENGTH_UNKNOWN);
    webServer.send(code, "text/html", httpMessage);

// Send script, style and meta
    webSendHttpContent(FPSTR(HTTP_SCRIPT));
    webSendHttpContent(FPSTR(HTTP_STYLE));

    if (meta.length() > 0) {
        webSendHttpContent(meta);
    }

// Send end of html header and start of html body
    webSendHttpContent(FPSTR(HTTP_HEADER_END));

// Send common content header
    webSendHttpContent(String(F("<h1>")));
    webSendHttpContent(String(uniqueNodeName));
    webSendHttpContent(String(F("</h1>")));

    if (type.length() > 0) {
        webSendHttpContent(String(F("<h2>")));
        webSendHttpContent(String(type));
        webSendHttpContent(String(F("</h2>")));
    }
}

void webStartHttpMsg(String type, int code) {
    webStartHttpMsg(type, String(F("")), code);
}

void webSendHttpContent(String content, String find, String replace) {
    content.replace(find, replace);
    webSendHttpContent(content);
}

void webSendHttpContent(String content) {
    webServer.sendContent(content);
}

void webEndHttpMsg() {
// Send end of html body
    webServer.sendContent(FPSTR(HTTP_END));

    webServer.sendContent("");
    webServer.setContentLength(CONTENT_LENGTH_NOT_SET);
}

void webHandleRoot() {
#ifdef DEBUG_ESPNODE
    debugPrintln(String(F("HTTP: WebHandleRoot called from client: ")) + webServer.client().remoteIP().toString());
#endif

    webStartHttpMsg(String(F("Navigation")), 200);

    webSendHttpContent(HTML_ROOT_SETTINGS);
    webSendHttpContent(HTML_ROOT_MQTT);
#ifdef RFID_MODE
    webSendHttpContent(HTML_ROOT_RFID);
#endif
    webSendHttpContent(HTML_ROOT_STATUS);

    webEndHttpMsg();

#ifdef DEBUG_ESPNODE
    debugPrintln(String(F("HTTP: WebHandleRoot page sent.")));
#endif
}

void webHandleSettings() {
#ifdef DEBUG_ESPNODE
    debugPrintln(String(F("HTTP: WebHandleSettings called from client: ")) + webServer.client().remoteIP().toString());
#endif

    webStartHttpMsg(String(F("Settings")), 200);

    String httpMessage = "";
    webSendHttpContent(HTML_SETTINGS_FORM_START);

    webSendHttpContent(HTML_SETTINGS_NODE_NAME, String(F("{nodeName}")), nodeName);

    webSendHttpContent(HTML_SETTINGS_WIFI_SSID, String(F("{wifiSsid}")), String(WiFi.SSID()));
    webSendHttpContent(HTML_SETTINGS_WIFI_PASSWD, String(F("{wifiSsid}")), MASKED_PASSWORD);

    webSendHttpContent(HTML_SETTINGS_ADMIN_USER, String(F("{configUser}")), String(configUser));
    webSendHttpContent(HTML_SETTINGS_ADMIN_PASSWD, String(F("{configPassword}")), (strlen(configPassword) != 0) ? MASKED_PASSWORD : String(F("")));

    webSendHttpContent(HTML_SETTINGS_BTN_SAVE_FORM_END);
    webSendHttpContent(HTML_SETTINGS_BTN_BACK);

    webEndHttpMsg();

#ifdef DEBUG_ESPNODE
    debugPrintln(String(F("HTTP: WebHandleSettings page sent.")));
#endif
}

void webHandleSaveSettings() {
#ifdef DEBUG_ESPNODE
    debugPrintln(String(F("HTTP: WebHandleSaveSettings called from client: ")) + webServer.client().remoteIP().toString());
    debugPrintln(String(F("HTTP: Checking for changed settings...")));
#endif

//check if node settings have changed
    if (webServer.arg(String(F("nodeName"))) != String(nodeName)) {
        configShouldSave = true;

        String lowerNodeName = webServer.arg(String(F("nodeName")));
        lowerNodeName.toLowerCase();
        lowerNodeName.toCharArray(nodeName, 32);
    }
    if (webServer.arg(String(F("configUser"))) != String(configUser)) {
        configShouldSave = true;

        webServer.arg(String(F("configUser"))).toCharArray(configUser, 32);
    }
    if (webServer.arg(String(F("configPassword"))) != String(MASKED_PASSWORD) && webServer.arg(String(F("configPassword"))) != String(configPassword)) {
        configShouldSave = true;

        webServer.arg(String(F("configPassword"))).toCharArray(configPassword, 32);
    }

//check if wifi settings have changed
    bool shouldSaveWifi = false;
    char wifiSsid[32] = "";
    char wifiPass[64] = "";
    if (webServer.arg(String(F("wifiSsid"))) != String(WiFi.SSID())) {
        shouldSaveWifi = true;

        webServer.arg(String(F("wifiSsid"))).toCharArray(wifiSsid, 32);

        if (webServer.arg(String(F("wifiPass"))) != String(MASKED_PASSWORD) && webServer.arg(String(F("mqttPassword"))) != String(wifiPass)) {
            webServer.arg(String(F("wifiPass"))).toCharArray(wifiPass, 64);
        }
    }

// Process config or wifi changes
    if (configShouldSave || shouldSaveWifi) {
        // Config updated, notify user and trigger write of configurations or wifi settings7
#ifdef DEBUG_ESPNODE
        debugPrintln(String(F("HTTP: Sending /saveSettings page to client connected from: ")) + webServer.client().remoteIP().toString());
#endif

        webStartHttpMsg(String(F("")), HTML_SAVESETTINGS_SAVE, 200);
        webSendHttpContent(HTML_SAVESETTINGS_SAVETEXT);
        webEndHttpMsg();

        if (configShouldSave) {
            delay(500);
            configSave();
        }

        if (shouldSaveWifi) {
            wifiConfig(wifiSsid, wifiPass);
        }

        nodeReset();
    }
    else {
        // No change found, notify user and link back to config page
#ifdef DEBUG_ESPNODE
        debugPrintln(String(F("HTTP: Sending /saveSettings page to client connected from: ")) + webServer.client().remoteIP().toString());
#endif

        webStartHttpMsg(String(F("")), HTML_SAVESETTINGS_NOCHANGE, 200);
        webSendHttpContent(HTML_SAVESETTINGS_NOCHANGETEXT);
        webEndHttpMsg();
    }

#ifdef DEBUG_ESPNODE
    debugPrintln(String(F("HTTP: WebHandleSaveSettings page sent.")));
#endif
}

void webHandleMqttSettings() {
#ifdef DEBUG_ESPNODE
    debugPrintln(String(F("HTTP: WebHandleMqttSettings called from client: ")) + webServer.client().remoteIP().toString());
#endif
    webStartHttpMsg(String(F("MQTT")), 200);

    webSendHttpContent(HTML_MQTT_FORM_START);
    webSendHttpContent(HTML_MQTT_SERVER, String(F("{mqttServer}")), String(mqttServer));
    webSendHttpContent(HTML_MQTT_PORT, String(F("{mqttPort}")), String(mqttPort));
    webSendHttpContent(HTML_MQTT_USER, String(F("{mqttUser}")), String(mqttUser));
    webSendHttpContent(HTML_MQTT_PASSWD, String(F("{mqttPassword}")), (strlen(mqttPassword) != 0) ? MASKED_PASSWORD : String(F("")));
    webSendHttpContent(HTML_MQTT_TOPIC, String(F("{mqttTopic}")), (strlen(mqttTopic) != 0) ? String(mqttTopic) : mqttGetDefaultTopic());
    webSendHttpContent(HTML_MQTT_STATUS, String(F("{mqttStatus}")), (mqttClient.connected()) ? String(F("connected")) : String(F("diconnected")));
    webSendHttpContent(HTML_MQTT_BTN_SAVE_FORM_END);
    webSendHttpContent(HTML_MQTT_BTN_BACK);

    webEndHttpMsg();
#ifdef DEBUG_ESPNODE
    debugPrintln(String(F("HTTP: WebHandleMqttSettings page sent.")));
#endif
}

void webHandleMqttSaveSettings() {
#ifdef DEBUG_ESPNODE
    debugPrintln(String(F("HTTP: WebHandleMqttSaveSettings called from client: ")) + webServer.client().remoteIP().toString());
    debugPrintln(String(F("HTTP: Checking for changed settings...")));
#endif

//check if mqtt settings have changed
    if (webServer.arg(String(F("mqttServer"))) != String(mqttServer)) {
        configShouldSave = true;

        webServer.arg(String(F("mqttServer"))).toCharArray(mqttServer, 64);
    }
    if (webServer.arg(String(F("mqttPort"))) != String(mqttPort)) {
        configShouldSave = true;

        webServer.arg(String(F("mqttPort"))).toCharArray(mqttPort, 6);
    }
    if (webServer.arg(String(F("mqttUser"))) != String(mqttUser)) {
        configShouldSave = true;

        webServer.arg(String(F("mqttUser"))).toCharArray(mqttUser, 32);
    }
    if (webServer.arg(String(F("mqttPassword"))) != String(MASKED_PASSWORD) && webServer.arg(String(F("mqttPassword"))) != String(mqttPassword)) {
        configShouldSave = true;

        webServer.arg(String(F("mqttPassword"))).toCharArray(mqttPassword, 32);
    }
    if (webServer.arg(String(F("mqttTopic"))) != String(mqttTopic) && webServer.arg(String(F("mqttTopic"))) != mqttGetDefaultTopic()) {
        configShouldSave = true;

        webServer.arg(String(F("mqttTopic"))).toCharArray(mqttTopic, 128);
    }

// Process config or wifi changes
    if (configShouldSave) {
        // Config updated, notify user and trigger write of configurations or wifi settings
#ifdef DEBUG_ESPNODE
        debugPrintln(String(F("HTTP: Sending /saveMqtt page to client connected from: ")) + webServer.client().remoteIP().toString());
#endif

        webStartHttpMsg(HTML_SAVESETTINGS_SAVE, 200);
        webSendHttpContent(HTML_SAVESETTINGS_SAVETEXT);
        webEndHttpMsg();

        if (configShouldSave) {
            delay(500);
            configSave();
        }

        nodeReset();
    }
    else {
        // No change found, notify user and link back to config page
#ifdef DEBUG_ESPNODE
        debugPrintln(String(F("HTTP: Sending /saveMqtt page to client connected from: ")) + webServer.client().remoteIP().toString());
#endif

        webStartHttpMsg(HTML_SAVESETTINGS_NOCHANGE, 200);
        webSendHttpContent(HTML_SAVESETTINGS_NOCHANGETEXT);
        webEndHttpMsg();
    }

#ifdef DEBUG_ESPNODE
    debugPrintln(String(F("HTTP: WebHandleMqttSaveSettings page sent.")));
#endif
}

void webHandleStatus() {
#ifdef DEBUG_ESPNODE
    debugPrintln(String(F("HTTP: WebHandleStatus called from client: ")) + webServer.client().remoteIP().toString());
#endif
    webStartHttpMsg(String(F("Status")), 200);

    webSendHttpContent(HTML_STATUS_FW_NAME, String(F("{firmwareName}")), String(fwName));
    webSendHttpContent(HTML_STATUS_FW_VERSION, String(F("{firmwareVersion}")), String(fwVersion));
    webSendHttpContent(HTML_STATUS_FW_FORM);
    webSendHttpContent(HTML_STATUS_CPU, String(F("{cpuFreq}")), String(ESP.getCpuFreqMHz()));
    webSendHttpContent(HTML_STATUS_SKETCH_SIZE, String(F("{sketchSize}")), String(ESP.getSketchSize()));
    webSendHttpContent(HTML_STATUS_SKETCH_FREESIZE, String(F("{freeSketchSize}")), String(ESP.getFreeSketchSpace()));
    webSendHttpContent(HTML_STATUS_HEAP, String(F("{freeHeap}")), String(ESP.getFreeHeap()));
    webSendHttpContent(HTML_STATUS_IPADDR, String(F("{ipAddr}")), String(WiFi.localIP().toString()));
    webSendHttpContent(HTML_STATUS_SIGSTRENGTH, String(F("{sigStrength}")), String(WiFi.RSSI()));
    unsigned long uptime = (millis() / 1000);
    webSendHttpContent(HTML_STATUS_UPTIME, String(F("{uptime}")), String(uptime));
    webSendHttpContent(HTML_STATUS_BTN_BACK);

    webEndHttpMsg();
#ifdef DEBUG_ESPNODE
    debugPrintln(String(F("HTTP: WebHandleStatus page sent.")));
#endif
}

void webHandleNotFound() {
#ifdef DEBUG_ESPNODE
    debugPrintln(String(F("HTTP: WebHandleNotFound called from client: ")) + webServer.client().remoteIP().toString());
#endif

    webStartHttpMsg(String(F("File Not Found\n\n")), 404);
    webSendHttpContent(String(F("URI: ")));
    webSendHttpContent(webServer.uri());
    webSendHttpContent(String(F("\nMethod: ")));
    webSendHttpContent((webServer.method() == HTTP_GET) ? String(F("GET")) : String(F("POST")));
    webSendHttpContent(String(F("\nArguments: ")));
    webSendHttpContent(String(webServer.args()));
    webSendHttpContent(String(F("\n")));

    for (uint8_t i = 0; i < webServer.args(); i++) {
        webSendHttpContent(" " + webServer.argName(i) + ": " + webServer.arg(i) + "\n");
    }

    webEndHttpMsg();
#ifdef DEBUG_ESPNODE
    debugPrintln(String(F("HTTP: WebHandleNotFound page sent.")));
#endif
}

void webLoop() {
    webServer.handleClient();
}

//***** RFID Functions *****//
#ifdef RFID_MODE

void rfidSetup() {
    SPI.begin(); // Init SPI bus
    rfid.PCD_Init(); // Init MFRC522
    delay(100);

    rfidInitNuid();

    //check rfid connection and firmware version
#ifdef DEBUG_ESPNODE
    debugPrintln(String(F("RFID: Connecting rfid controller...")));
#endif

    rfidControllerData = "";

    byte version = rfid.PCD_ReadRegister(MFRC522::PCD_Register::VersionReg);
    rfidControllerData = "Firmware Version: " + String(version, HEX);

    // When 0x00 or 0xFF is returned, communication probably failed
    if ((version == 0x00) || (version == 0xFF)) {
        rfidControllerData = String(F("Communication failure, is the MFRC522 properly connected?"));

#ifdef DEBUG_ESPNODE
        debugPrintln(String(F("RFID: ")) + rfidControllerData);
#endif
    }
    else {
#ifdef DEBUG_ESPNODE
        debugPrintln(String(F("RFID: Connected rfid controller - ")) + rfidControllerData);
#endif
    }
}

void rfidInitNuid() {
    //initialize key
    for (byte i = 0; i < 4; i++) {
        rfidNuidPICC[i] = 0xFF;
    }
}

void rfidLoop() {
    // Send pending mqtt message
    if (rfidCardPending) {
        rfidCardPending = !mqttSend(mqttGetNodeTopic(String(F("rfid-uid"))), rfidNuidString);
    }

    // Throttle control for spi read
    if (rfidLastReadMillis != 0) {
        unsigned long millisPassed = millis() - rfidLastReadMillis;
        if (millisPassed < RFID_CARD_READ_TIMEOUT) {
            return;
        }
        else {
            rfidLastReadMillis = 0;
            rfidInitNuid();
            rfidNuidString = "0";
            rfidCardPending = true;
        }
    }

    // Reset the loop if no new card present on the sensor/reader. This saves the entire process when idle.
    if (!rfid.PICC_IsNewCardPresent())
        return;
    // Verify if the NUID has been readed
    if (!rfid.PICC_ReadCardSerial())
        return;

#ifdef DEBUG_ESPNODE
    debugPrint(F("RFID: PICC type - "));
#endif

    MFRC522::PICC_Type piccType = rfid.PICC_GetType(rfid.uid.sak);

#ifdef DEBUG_ESPNODE
    debugPrintln(rfid.PICC_GetTypeName(piccType));
#endif

    // Check is the PICC of Classic MIFARE type
    if (piccType != MFRC522::PICC_TYPE_MIFARE_MINI && piccType != MFRC522::PICC_TYPE_MIFARE_1K && piccType != MFRC522::PICC_TYPE_MIFARE_4K) {
#ifdef DEBUG_ESPNODE
        debugPrintln(F("RFID: Your tag is not of type MIFARE Classic."));
#endif

        return;
    }
    if (rfid.uid.uidByte[0] != rfidNuidPICC[0] || rfid.uid.uidByte[1] != rfidNuidPICC[1] || rfid.uid.uidByte[2] != rfidNuidPICC[2] || rfid.uid.uidByte[3] != rfidNuidPICC[3]) {
#ifdef DEBUG_ESPNODE
        debugPrint(F("RFID: A new card has been detected - "));
#endif

        // Store NUID into nuidPICC array and set nuidString
        rfidNuidString = "";
        for (byte i = 0; i < 4; i++) {
            rfidNuidPICC[i] = rfid.uid.uidByte[i];
            rfidNuidString += rfid.uid.uidByte[i];
        }

#ifdef DEBUG_ESPNODE
        debugPrintln(rfidNuidString);
#endif

        // Trigger send rfid uid via mqtt and set timestamp
        rfidCardPending = true;
        rfidLastReadMillis = millis();
    }
    else {
#ifdef DEBUG_ESPNODE
        debugPrintln(F("RFID: Card read previously."));
#endif
    }

    // Halt PICC
    rfid.PICC_HaltA();
    // Stop encryption on PCD
    rfid.PCD_StopCrypto1();
}

void webHandleRfid() {
#ifdef DEBUG_ESPNODE
    debugPrintln(String(F("HTTP: WebHandleRfid called from client: ")) + webServer.client().remoteIP().toString());
#endif
    webStartHttpMsg(String(F("RFID")), 200);

    webSendHttpContent(HTML_RFID_STATUS, String(F("{rfidControllerData}")), rfidControllerData);
    webSendHttpContent(HTML_RFID_LASTNUID, String(F("{rfidNuidString}")), rfidNuidString);
    webSendHttpContent(HTML_RFID_BTN_BACK);

    webEndHttpMsg();
#ifdef DEBUG_ESPNODE
    debugPrintln(String(F("HTTP: WebHandleRfid page sent.")));
#endif
}
#endif

//***** RFID Functions *****//
#ifdef MULTI_SENSOR_MODE

void multiSetup() {
    Wire.begin(D2, D1);
    multiAdcSensorInitialized = multiAdc.begin();

#ifdef DEBUG_ESPNODE
    if (!multiAdcSensorInitialized) {
        debugPrintln(String(F("MULTI: Failed to initialize ADC.")));
    }
#endif

    if (multiAdcSensorInitialized) {
        // Setup MQ2 sensor
        multiMqSensor.setRegressionMethod(1); // _PPM =  a*ratio^b
        multiMqSensor.setA(30000000); // Configure for smoke concentration
        multiMqSensor.setB(-8.308);
        multiMqSensor.init();

        multiMqSensorState = String(F("Pending: Warming up..."));
    }
    else {
        multiMqSensorState = String(F("Error: ADC initialization failed."));
    }

    pinMode(MULTI_MOTION_PIN, INPUT);
}

int16_t multiMqReadAdcRaw() {
    return multiAdc.readADC_SingleEnded(MULTI_ADC_MQ_PIN);
}
bool multiMqWarmUp() {
    if (multiMqWarmedUp) {
        return true;
    }

    if (multiAdcSensorInitialized && !multiMqWarmedUp) {
        unsigned long secondsPassed = 0;

        if (multiMqWarmupTimer == 0) {
            multiMqWarmupTimer = millis();
            multiMqSensorState = String(F("Pending: Calibrating sensor..."));

#ifdef DEBUG_ESPNODE
            debugPrintln(String(F("MULTI: MQ2 sensor warming up for ")) + String(MULTI_MQ2_WARMUP_SEC) + String(F(" sec...")));
#endif
        }
        else {
            secondsPassed = (millis() - multiMqWarmupTimer) / 1000;
        }

        multiMqWarmedUp = (secondsPassed >= MULTI_MQ2_WARMUP_SEC);

#ifdef DEBUG_ESPNODE
        if (multiMqWarmedUp) {
            debugPrintln(String(F("MULTI: MQ2 sensor warmed up.")));
        }
#endif
    }

    return false;
}

bool multiMqCalibrate() {
    if (multiMqCalibrated) {
        return true;
    }

    if (multiMqWarmUp() && !multiMqCalibrated) {
#ifdef DEBUG_ESPNODE
        debugPrintln("MULTI: MQ sensor calibrating please wait...");
#endif

        float calcR0 = 0;
        for (int i = 1; i <= 10; i++) {
            multiMqSensor.setADC(multiMqReadAdcRaw());
            calcR0 += multiMqSensor.calibrate(MULTI_MQ2_RATIO_CLEANAIR);
        }
        multiMqSensor.setR0(calcR0 / 10);

        if (isinf(calcR0)) {
            multiMqSensorState = String(F("Error: Connection issue founded, R0 is infite."));

#ifdef DEBUG_ESPNODE
            debugPrintln("MULTI: Warning, MQ sensor connection issue founded, R0 is infite (open circuit detected) please check your wiring and supply.");
#endif
        }
        else if (calcR0 == 0) {
            multiMqSensorState = String(F("Error: Connection issue founded, R0 i zero."));

#ifdef DEBUG_ESPNODE
            debugPrintln("MULTI: Warning, MQ sensor connection issue founded, R0 is zero (Analog pin with short circuit to ground) please check your wiring and supply");
#endif
        }
        else {
            multiMqCalibrated = true;
#ifdef DEBUG_ESPNODE
            debugPrintln("MULTI: MQ sensor calibrated.");
#endif
        }
    }

    return false;
}

void multiMqLoop() {
    if (multiMqWarmUp() && multiMqCalibrate()) {
        multiMqSensor.setADC(multiMqReadAdcRaw());

        float smokePPM = multiMqSensor.readSensor(); // Sensor will read PPM concentration using the model and a and b values setted before or in the setup
        boolean smokeDetected = (smokePPM >= multiMqSmokeLimit);

        if (multiMqSmokeFirstRead || (smokeDetected != multiMqSmokeDetected)) {
            mqttSend(mqttGetNodeTopic(String(F("smoke"))), smokeDetected ? "true" : "false");
        }

        multiMqSmokeDetected = smokeDetected;   // Save result and send message if value changes
        multiMqSmokeFirstRead = false;

#ifdef DEBUG_ESPNODE
        if (smokeDetected) {
            debugPrintln("Warning: High concentrations of smoke detected");
        }
#endif
    }
}

void multiLightLoop() {
    int16_t lightRawValue = multiAdc.readADC_SingleEnded(MULTI_ADC_LIGHT_PIN);
    int16_t lightVoltValue = multiAdc.computeVolts(lightRawValue);

    long lightPercentage = map(lightVoltValue, 4, 0, 0, 100);
    lightPercentage = constrain(lightPercentage, 0, 100);

    if (lightPercentage != multiLightPercentage) {
        mqttSend(mqttGetNodeTopic(String(F("light"))), String(lightPercentage));
    }

    multiLightPercentage = lightPercentage;   // Save result and send message if value changes
}

void multiMotionLoop() {

    bool motionDetected = digitalRead(MULTI_MOTION_PIN);

    if (multiMotionFirstRead || (motionDetected != multiMotionDetected)) {
        mqttSend(mqttGetNodeTopic(String(F("motion"))), motionDetected ? "true" : "false");
    }

    multiMotionDetected = motionDetected;   // Save result and send message if value changes
    multiMotionFirstRead = false;
}

void multiLoop() {
    multiMqLoop();
    multiLightLoop();
    multiMotionLoop();
}

#endif

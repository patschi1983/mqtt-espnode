//#define RFID_MODE
#define BUTTON_MODE

//#define MULTI_SENSOR_MODE

#ifdef RFID_MODE
#ifdef MULTI_SENSOR_MODE
#error "RFID_MODE and MULTI_SENSOR_MODE cannot be mixed."
#endif
#endif

#ifdef BUTTON_MODE
#ifdef MULTI_SENSOR_MODE
#error "RFID_MODE and MULTI_SENSOR_MODE cannot be mixed."
#endif
#endif

//*****************************************************************************************************************//

#include "Arduino.h"

#include <EEPROM.h>
#include <ArduinoJson.h>
#include <WiFiManager.h>
#include <MQTTClient.h>
#include <RemoteDebug.h>
#include <OneButton.h>

#ifdef ESP8266
#include <ESP8266WebServer.h>
#include <ESP8266HTTPUpdateServer.h>
#elif ESP32
#include <WebServer.h>
#include <HTTPUpdateServer.h>
#else
#error "Wrong board - ESP8266 or ESP32 must be used."
#endif

#ifdef BUTTON_MODE
#include <OneButton.h>
#endif

#ifdef RFID_MODE
#include <MFRC522.h>
#endif

#ifdef MULTI_SENSOR_MODE
#include <Wire.h>
#include <Adafruit_ADS1X15.h>
#include <MQUnifiedsensor.h>
#endif

//***** ESP Node *****//
char fwName[16] = "mqtt_espnode";         // Name of the firmware
char fwVersion[8] = "0.1-2";              // Version of the firmware
byte espMac[6];                           // Byte array to store our MAC address

char nodeName[32] = "espnode";                  // Nodes name - default value, may be overridden
char uniqueNodeName[128] = "";                  // Unique node name, generated by combining node name and parts of the mac address
char configUser[32] = "admin";                  // User name for web access - default value, may be overridden
char configPassword[32] = "";                   // Password for web access - default value, may be overridden

//***** Config *****//
const unsigned long CONNECT_TO = 300;           // Timeout for WiFi and MQTT connection attempts in seconds
const unsigned long RECONNECT_TO = 15;          // Timeout for WiFi reconnection attempts in seconds
const int CONFIG_SIZE = 10240;                  // Configuration size
bool debugSerialEnabled = true;                 // Enable serial debug - default value, may be overridden
bool debugRemoteEnabled = false;                // Enable remote debug - default value, may be overridden
RemoteDebug debugRemote;                        // Handler for remote debug

//***** WebServer *****//
#ifdef ESP8266
ESP8266WebServer webServer(80);
ESP8266HTTPUpdateServer webUpdateServer;
#elif ESP32
WebServer webServer(80);
HTTPUpdateServer webUpdateServer;
#else
#error "Wrong board - ESP8266 or ESP32 must be used."
#endif

const char MASKED_PASSWORD[] = "********";

//***** MQTT *****//
const uint16_t MQTT_BUFFER = 4096;              // Size of buffer for incoming MQTT message
const unsigned long MQTT_RETRY_DELAY = 10000;   // Delay for reconnect
unsigned long mqttRetryMillis = 0;              // Timestamp used to measure delay for retry
WiFiClient mqttWifiClient;
MQTTClient mqttClient(MQTT_BUFFER);
char mqttServer[64] = "";              // MQTT Server IP/URL - Default value, maybe overridden
int mqttPort = 1883;                   // MQTT Server Port - Default value, maybe overridden
char mqttUser[32] = "";                // MQTT User name - Default value, maybe overridden
char mqttPassword[32] = "";            // MQTT Password - Default value, maybe overridden
char mqttTopic[128] = "";              // MQTT Topic - Default value, maybe overridden
const char mqttDefaultTopicBase[16] = "espnodes/";    // MQTT Base for default topic
const char mqttAvailableSubTopic[16] = "available";   // MQTT available sub topic topic
boolean mqttAvailableMsgPending = false;              // MQTT flag indicating if availability status is pending

//***** BUTTON *****//
#ifdef BUTTON_MODE
#define BTN_TYPE_SINGLE 1
#define BTN_TYPE_DOUBLE 2
#define BTN_TYPE_MULTI 3
#define BTN_TYPE_LONG 4
#define BTN_CMD_1X "Cmd1x"
#define BTN_CMD_2X "Cmd2x"
#define BTN_CMD_MU "CmdMu"
#define BTN_CMD_LO "CmdLo"

int currentButtonIndex = 0;                       // Control variable for loop

const char BTN_CMD_SEPERATOR[2] = "#";

#ifdef ESP8266
#ifdef RFID_MODE
const uint16_t NUM_OF_BUTTONS = 3;
int btnId[NUM_OF_BUTTONS] = { 0, 1, 2 };
const char btnName[NUM_OF_BUTTONS][16] = { "btnD1", "btnD2", "btnA0" };
char btnMqttCmdSingle[NUM_OF_BUTTONS][128] = { "", "", "" };
char btnMqttCmdDouble[NUM_OF_BUTTONS][128] = { "", "", "" };
char btnMqttCmdMulti[NUM_OF_BUTTONS][128] = { "", "", "" };
char btnMqttCmdLong[NUM_OF_BUTTONS][128] = { "", "", "" };
int btnPins[NUM_OF_BUTTONS] = { D1, D2, A0 };
OneButton *btnArray[NUM_OF_BUTTONS];
#else
const uint16_t NUM_OF_BUTTONS = 6;
int btnId[NUM_OF_BUTTONS] = { 0, 1, 2, 3, 4, 5 };
const char btnName[NUM_OF_BUTTONS][16] = { "btnD1", "btnD2", "btnD5", "btnD6", "btnD7", "btnA0" };
char btnMqttCmdSingle[NUM_OF_BUTTONS][128] = { "", "", "", "", "", "" };
char btnMqttCmdDouble[NUM_OF_BUTTONS][128] = { "", "", "", "", "", "" };
char btnMqttCmdMulti[NUM_OF_BUTTONS][128] = { "", "", "", "", "", "" };
char btnMqttCmdLong[NUM_OF_BUTTONS][128] = { "", "", "", "", "", "" };
int btnPins[NUM_OF_BUTTONS] = { D1, D2, D5, D6, D7, A0 };
OneButton *btnArray[NUM_OF_BUTTONS];
#endif

#elif ESP32
const uint16_t NUM_OF_BUTTONS = 20;
int btnId[NUM_OF_BUTTONS] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19 };
const char btnName[NUM_OF_BUTTONS][16] = { "btn05", "btn13", "btn14", "btn15", "btn16", "btn17", "btn18", "btn19", "btn21", "btn22", "btn23", "btn25", "btn26", "btn27", "btn32", "btn33", "btn34", "btn35", "btn36", "btn39" };
char btnMqttCmdSingle[NUM_OF_BUTTONS][128] = { "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "" };
char btnMqttCmdDouble[NUM_OF_BUTTONS][128] = { "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "" };
char btnMqttCmdMulti[NUM_OF_BUTTONS][128] = { "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "" };
char btnMqttCmdLong[NUM_OF_BUTTONS][128] = { "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "" };
int btnPins[NUM_OF_BUTTONS] = { 5, 13, 14, 15, 16, 17, 18, 19, 21, 22, 23, 25, 26, 27, 32, 33, 34, 35, 36, 39 };
OneButton *btnArray[NUM_OF_BUTTONS];

#else
#error "Wrong board - ESP8266 or ESP32 must be used."
#endif
#endif

//***** RFID *****//
#ifdef RFID_MODE
#ifdef ESP8266
// RST=D3, SDA=D8, SCK=D5, MOSI=D7, MISO=D6
#define SS_PIN D8
#define RST_PIN D3
#elif ESP32
#error "Wrong board - ESP8266 must be used."   // "Wrong board - ESP8266 or ESP32 must be used."
#else
#error "Wrong board - ESP8266 must be used."   // "Wrong board - ESP8266 or ESP32 must be used."
#endif

MFRC522 rfid(SS_PIN, RST_PIN);
byte rfidNuidPICC[4];
String rfidNuidString;
String rfidControllerData;
unsigned long rfidLastReadMillis = 0;
const unsigned long RFID_CARD_READ_TIMEOUT = 5000;
bool rfidCardPending = false;
#endif

//***** MULTISENSOR *****//
#ifdef MULTI_SENSOR_MODE
Adafruit_ADS1115 multiAdc;               // ADC definition
#define MULTI_ADC_LIGHT_PIN 0            // ADC pin where light sensor is connected
#define MULTI_ADC_MQ_PIN 2               // ADC pin where MQ2 is connected
#define MULTI_ADC_MOTION_PIN 1           // ADC pin where motion sensor is connected
#define MULTI_ADC_VOLTAGE 5              // ADC voltage resolution
#define MULTI_ADC_RES 16                 // ADC resolution

bool multiAdcSensorInitialized = false;  // Bool holding the initialization state of the adc

#define MULTI_MQ_BOARD "ESP8266"            // Board definition
#define MULTI_MQ_TYPE "MQ2/ADS1115"         // MQ-Type definition
#define MULTI_MQ2_RATIO_CLEANAIR (9.83)     // MQ2 clean air ratio
#define MULTI_MQ2_WARMUP_SEC 20                 // MQ warmup time in sec

MQUnifiedsensor multiMqSensor(MULTI_MQ_BOARD, MULTI_ADC_VOLTAGE, MULTI_ADC_RES, -1, MULTI_MQ_TYPE);
unsigned long multiMqWarmupTimer = 0;       // Timestamp used to measure the warmup time
bool multiMqWarmedUp = false;               // Flag indicating that warmup has been done
bool multiMqCalibrated = false;             // Flag indicating that calibration has been done
String multiMqSensorState = "Initial";      // String holding the current state of the MQ sensor
int multiMqSmokeLimit = 500;                // Smoke limit in ppm - Default value, maybe overridden
bool multiMqSmokePending = true;            // Flag indicating that a smoke message is pending, true to send initial state
bool multiMqSmokeDetected = false;          // Flag indicating if smoke was detected, last read value
int multiMqSmokeHoldTime = 30;              // Minimum hold time for smoke detection state (sec) - Default value, maybe overridden
unsigned long multiMqSmokeHoldTimer = 0;    // Timestamp used to measure the hold time

int16_t multiLightVoltage = 0;              // Long holding last read light voltage value
long multiLightPercentage = 0;              // Long holding last read light percentage value
long multiLightMinValue = 4;                // Minimum voltage indicating 0% light - Default value, maybe overridden
long multiLightMaxValue = 0;                // Maximum voltage indicating 100% light - Default value, maybe overridden

bool multiMotionPending = true;            // Flag indicating that a motion message is pending, true to send initial state
bool multiMotionDetected = false;          // Flag indicating if smoke was detected, last read value
int multiMotionHoldTime = 5;               // Minimum hold time for motion detection state (sec) - Default value, maybe overridden
unsigned long multiMotionHoldTimer = 0;    // Timestamp used to measure hold time

#endif

//***** HTML Text - Root *****//
const char HTML_ROOT_SETTINGS[] PROGMEM = "<a href='/settings'><button>Settings</button></a>";
#ifdef BUTTON_MODE
const char HTML_ROOT_BUTTONS[] PROGMEM = "<hr><a href='/buttons'><button>Buttons</button></a>";
#endif
#ifdef RFID_MODE
const char HTML_ROOT_RFID[] PROGMEM = "<hr><a href='/rfid'><button>RFID</button></a>";
#endif
#ifdef MULTI_SENSOR_MODE
const char HTML_ROOT_MULTI[] PROGMEM = "<hr><a href='/multi'><button>Multi Sensor</button></a>";
#endif
const char HTML_ROOT_STATUS[] PROGMEM = "<hr><a href='/status'><button>Status</button></a>";

//***** HTML Text - Setting *****//
const char HTML_SETTINGS_FORM_START[] PROGMEM = "<form method='POST' action='saveSettings'>";
const char HTML_SETTINGS_NODE_NAME[] PROGMEM = "<b>Node Name</b> <i><small>(required. lowercase letters, numbers, and _ only)</small></i><input id='nodeName' required name='nodeName' maxlength=31 placeholder='Node Name' pattern='[a-z0-9_]*' value='{nodeName}'>";
const char HTML_SETTINGS_WIFI_SSID[] PROGMEM = "<br/><br/><b>WiFi SSID</b> <i><small>(required)</small></i><input id='wifiSsid' required name='wifiSsid' maxlength=32 placeholder='WiFi SSID' value='{wifiSsid}'>";
const char HTML_SETTINGS_WIFI_PASSWD[] PROGMEM = "<br/><b>WiFi Password</b> <i><small>(optional)</small></i><input id='wifiPass' name='wifiPass' type='password' maxlength=64 placeholder='WiFi Password' value='{wifiPass}'>";
const char HTML_SETTINGS_ADMIN_USER[] PROGMEM = "<br/><br/><b>Admin Username</b> <i><small>(optional)</small></i><input id='configUser' name='configUser' maxlength=31 placeholder='Admin User' value='{configUser}'>";
const char HTML_SETTINGS_ADMIN_PASSWD[] PROGMEM = "<br/><b>Admin Password</b> <i><small>(optional)</small></i><input id='configPassword' name='configPassword' type='password' maxlength=31 placeholder='Admin User Password' value='{configPassword}'>";
const char HTML_SETTINGS_MQTT_SERVER[] PROGMEM = "<br/><br/><b>MQTT Broker</b> <i><small>(required)</small></i><input id='mqttServer' required name='mqttServer' maxlength=63 placeholder='mqttServer' value='{mqttServer}'>";
const char HTML_SETTINGS_MQTT_PORT[] PROGMEM = "<br/><b>MQTT Port</b> <i><small>(required)</small></i><input id='mqttPort' required name='mqttPort' type='number' maxlength=5 placeholder='1883' value='{mqttPort}'>";
const char HTML_SETTINGS_MQTT_USER[] PROGMEM = "<br/><b>MQTT User</b> <i><small>(optional)</small></i><input id='mqttUser' name='mqttUser' maxlength=31 placeholder='mqttUser' value='{mqttUser}'>";
const char HTML_SETTINGS_MQTT_PASSWD[] PROGMEM = "<br/><b>MQTT Password</b> <i><small>(optional)</small></i><input id='mqttPassword' name='mqttPassword' type='password' maxlength=31 placeholder='mqttPassword' value='{mqttPassword}'>";
const char HTML_SETTINGS_MQTT_TOPIC[] PROGMEM = "<br/><b>MQTT Topic</b> <i><small>(optional)</small></i><input id='mqttTopic' name='mqttTopic' maxlength=127 value='{mqttTopic}'>";
const char HTML_SETTINGS_MQTT_STATUS[] PROGMEM ="<br/><b>MQTT Status</b><input id='mqttSatus' readonly name='mqttSatus' placeholder='mqttStatus' value='{mqttStatus}'>";
const char HTML_SETTINGS_DEBUG_SERIAL[] PROGMEM = "<br/><br/><b>Debug Serial Enabled</b> <i><small>(0/1)</small></i><input id='debugSerialEnabled' name='debugSerialEnabled' type='number' min='0' max='1' value='{debugSerialEnabled}'>";
const char HTML_SETTINGS_DEBUG_REMOTE[] PROGMEM ="<br/><b>Debug Remote Enabled</b><i> <small>(0/1)</small></i><input id='debugRemoteEnabled' name='debugRemoteEnabled' type='number' min='0' max='1' value='{debugRemoteEnabled}'>";
const char HTML_SETTINGS_BTN_SAVE_FORM_END[] PROGMEM ="<br/><br/><button type='submit'>Save</button></form>";
const char HTML_SETTINGS_BTN_BACK[] PROGMEM ="<hr><a href='/'><button>Back</button></a>";

//***** HTML Text - SaveSetting *****//
const char HTML_SAVESETTINGS_START_REDIR_15SEC[] PROGMEM = "<meta http-equiv='refresh' content='15;url={redirectUrl}' />";
const char HTML_SAVESETTINGS_START_REDIR_3SEC[] PROGMEM = "<meta http-equiv='refresh' content='3;url={redirectUrl}' />";
const char HTML_SAVESETTINGS_SAVE_RESTART[] PROGMEM = "<br/>Saving updated configuration values and restarting device ... <a href='{redirectUrl}'>redirect</a>";
const char HTML_SAVESETTINGS_SAVE_NORESTART[] PROGMEM = "<br/>Saving updated configuration values and updating device ... <a href='{redirectUrl}'>redirect</a>";
const char HTML_SAVESETTINGS_NOCHANGE[] PROGMEM = "<br/>No changes found ... redirecting to <a href='{redirectUrl}'>redirecting</a>";
const char HTML_REPLACE_REDIRURL[] PROGMEM = "{redirectUrl}";

//***** HTML Text - Status *****//
const char HTML_STATUS_FW_NAME[] PROGMEM = "<b>FW Name: </b> {firmwareName}";
const char HTML_STATUS_FW_VERSION[] PROGMEM = "<br/><b>FW Name: </b> {firmwareVersion}";
const char HTML_STATUS_FW_FORM[] PROGMEM = "<form method='POST' action='/updateFw' enctype='multipart/form-data'> <hr> <b>FW Upload: </b> <input type='file' accept='.bin,.bin.gz' name='firmware'> <button>Update Firmware</button> </form> <hr>";
const char HTML_STATUS_CPU[] PROGMEM = "<br/><b>CPU Frequency: </b> {cpuFreq} MHz";
const char HTML_STATUS_SKETCH_SIZE[] PROGMEM = "<br/><b>Sketch Size: </b> {sketchSize} bytes";
const char HTML_STATUS_SKETCH_FREESIZE[] PROGMEM = "<br/><b>Free Sketch Space: </b> {freeSketchSize} bytes";
const char HTML_STATUS_HEAP[] PROGMEM = "<br/><b>Heap Free: </b> {freeHeap}";
const char HTML_STATUS_IPADDR[] PROGMEM = "<br/><b>IP Address: </b> {ipAddr}";
const char HTML_STATUS_SIGSTRENGTH[] PROGMEM = "<br/><b>Signal Strength: </b> {sigStrength}";
const char HTML_STATUS_UPTIME[] PROGMEM = "<br/><b>Uptime: </b> {uptime} sec";
const char HTML_STATUS_BTN_BACK[] PROGMEM = "<hr><a href='/'><button>Back</button></a>";

//***** HTML Text - BUTTON *****//
#ifdef BUTTON_MODE
const char HTML_BUTTONS_FORM_START[] PROGMEM = "<form method='POST' action='saveButtons'>";
const char HTML_BUTTONS_SECTION_START[] PROGMEM = "<h3>{buttonName}</h3>";
const char HTML_BUTTONS_CMD_1X[] PROGMEM = "<b>Command Single</b> <i><small>(disabled, if empty)</small></i>";
const char HTML_BUTTONS_CMD_2X[] PROGMEM = "<br/><b>Command Double</b> <i><small>(disabled, if empty)</small></i>";
const char HTML_BUTTONS_CMD_MULTI[] PROGMEM = "<br/><b>Command Multi</b> <i><small>(disabled, if empty)</small></i>";
const char HTML_BUTTONS_CMD_LONG[] PROGMEM = "<br/><b>Command Long</b> <i><small>(disabled, if empty)</small></i>";
const char HTML_BUTTONS_CMD_MQTT[] PROGMEM = "<input id='{btnCfgId}' name='{btnCfgId}' maxlength=127 placeholder='{btnDefaultCmd}' value='{btnCmd}'>";
const char HTML_BUTTONS_FORM_END[] PROGMEM ="<br/><br/><button type='submit'>Save</button></form>";
const char HTML_BUTTONS_BTN_BACK[] PROGMEM = "<hr><a href='/'><button>Back</button></a>";

#endif

//***** HTML Text - RFID *****//
#ifdef RFID_MODE
const char HTML_RFID_STATUS[] PROGMEM = "<b>RFID-Status: </b> {rfidControllerData}";
const char HTML_RFID_LASTNUID[] PROGMEM = "<br/><b>Last RFID: </b> {rfidNuidString}";
const char HTML_RFID_BTN_BACK[] PROGMEM = "<hr><a href='/'><button>Back</button></a>";
#endif

//***** HTML Text - MULTISENSOR *****//
#ifdef MULTI_SENSOR_MODE
const char HTML_MULTI_FORM_START[] PROGMEM = "<form method='POST' action='saveMulti'>";
const char HTML_MULTI_ADC_STATUS[] PROGMEM = "<b>ADC Status</b><input id='multiAdcSensorInitialized' readonly name='multiAdcSensorInitialized' placeholder='unknown' value='{multiAdcSensorInitialized}'>";
const char HTML_MULTI_MQ_STATUS[] PROGMEM = "<br/><br/><b>Smoke Sensor Status</b><input id='multiMqSensorState' readonly name='multiMqSensorState' placeholder='unknown' value='{multiMqSensorState}'>";
const char HTML_MULTI_MQ_SMOKE_STATUS[] PROGMEM = "<br/><b>Smoke Status</b><input id='multiMqSmokeDetected' readonly name='multiMqSmokeDetected' placeholder='unknown' value='{multiMqSmokeDetected}'>";
const char HTML_MULTI_MQ_SMOKE_LIMIT[] PROGMEM = "<br/><b>Smoke Limit (ppm)</b> <i><small>(required)</small></i><input id='multiMqSmokeLimit' required name='multiMqSmokeLimit' type='number' maxlength=5 placeholder='500' value='{multiMqSmokeLimit}'>";
const char HTML_MULTI_MQ_HOLDTIME[] PROGMEM = "<br/><b>Smoke Hold Time (sec)</b> <i><small>(required)</small></i><input id='multiMqSmokeHoldTime' required name='multiMqSmokeHoldTime' type='number' maxlength=5 placeholder='30' value='{multiMqSmokeHoldTime}'>";
const char HTML_MULTI_LIGHT_VAL[] PROGMEM = "<br/><br/><b>Light Sensor (v/%)</b><input id='multiLightSensorValue' readonly name='multiLightSensorValue' placeholder='unknown' value='{multiLightSensorValue}'>";
const char HTML_MULTI_LIGHT_MIN_VAL[] PROGMEM = "<br/><b>Light Sensor Min (v)</b><input id='multiLightMinValue' name='multiLightMinValue' type='number' maxlength=5 placeholder='4' value='{multiLightMinValue}'>";
const char HTML_MULTI_LIGHT_MAX_VAL[] PROGMEM = "<br/><b>Light Sensor Max (v)</b><input id='multiLightMaxValue' name='multiLightMaxValue' type='number' maxlength=5 placeholder='0' value='{multiLightMaxValue}'>";
const char HTML_MULTI_MOTION_VAL[] PROGMEM = "<br/><br/><b>Motion Sensor</b><input id='multiMotionDetected' readonly name='multiMotionDetected' placeholder='unknown' value='{multiMotionDetected}'>";
const char HTML_MULTI_MOTION_HOLDTIME[] PROGMEM = "<br/><b>Motion Hold Time (sec)</b> <i><small>(required)</small></i><input id='multiMotionHoldTime' required name='multiMotionHoldTime' type='number' maxlength=5 placeholder='5' value='{multiMotionHoldTime}'>";
const char HTML_MULTI_BTN_SAVE_FORM_END[] PROGMEM ="<br/><br/><button type='submit'>Save</button></form>";
const char HTML_MULTI_BTN_BACK[] PROGMEM = "<hr><a href='/'><button>Back</button></a>";
#endif

//*****************************************************************************************************************//
void setup() {
    debugSetup();

    configRead();

    nodeSetup();

    wifiSetup();

    mqttSetup();

    webSetup();

#ifdef BUTTON_MODE
    btnSetup();
#endif

#ifdef RFID_MODE
    rfidSetup();
#endif

#ifdef MULTI_SENSOR_MODE
    multiSetup();
#endif

    debugSetupFinalize();
}

//*****************************************************************************************************************//
void loop() {
    debugLoop();

    wifiLoop();

    mqttLoop();

    webLoop();

#ifdef BUTTON_MODE
    btnLoop();
#endif

#ifdef RFID_MODE
    rfidLoop();
#endif

#ifdef MULTI_SENSOR_MODE
    multiLoop();
#endif
}

//*****************************************************************************************************************//

//***** Node Functions *****//
void nodeSetup() {
    WiFi.macAddress(espMac);            // Read our MAC address and save it to espMac

    String uniqueName = String(nodeName) + "-" + String(espMac[0], HEX) + String(espMac[1], HEX) + String(espMac[2], HEX) + String(espMac[3], HEX) + String(espMac[4], HEX) + String(espMac[5], HEX);
    strcpy(uniqueNodeName, uniqueName.c_str());
}

void nodeReset() {
    debugPrintln(F("RESET: reset"));

    mqttSendAvailable(true);
    delay(500);
    ESP.restart();
    delay(5000);
}

//***** Debug Functions ****//

void debugSetup() {
    // Setup serial for debug output
    Serial.begin(115200);
    Serial.println();

    // Setup telnet server for remote debug output
    debugRemote.begin(uniqueNodeName); // Initialize the WiFi server
    debugRemote.setResetCmdEnabled(true); // Enable the reset command
    debugRemote.showProfiler(true); // Profiler (Good to measure times, to optimize codes)
    debugRemote.showColors(true); // Colors

    debugPrintln(String(F("********************************************************************************")));
    debugPrintln(String(F("SYSTEM: Starting ")) + String(fwName) + String(F(" v")) + String(fwVersion));
    debugPrintln(String(F("SYSTEM: debug server enabled at - ")) + WiFi.localIP().toString());
}

void debugSetupFinalize() {
    if (!debugSerialEnabled) {
        debugPrintln(String(F("SYSTEM: Stopping serial debug due to configuration")));

        Serial.flush();
        Serial.end();
    }

    if (!debugRemoteEnabled) {
        debugPrintln(String(F("SYSTEM: Stopping remote debug due to configuration")));

        debugRemote.stop();
    }
}

void debugLoop() {
    if (debugRemoteEnabled) {
        debugRemote.handle();
    }
}

void debugPrintln(String debugText) {
    if (!debugSerialEnabled && !debugRemoteEnabled) {
        // No debug enabled so do nothing
        return;
    }

    if (debugSerialEnabled || debugRemoteEnabled) {
        String debugTimeText = "[+" + String(float(millis()) / 1000, 3) + "s] " + debugText;

        if (debugSerialEnabled) {
            Serial.println(debugTimeText);
            Serial.flush();
        }

        if (debugRemoteEnabled) {
            debugRemote.println(debugTimeText);
        }
    }
}

//***** Config Functions *****//
void configRead() {
    // Read saved config.json from SPIFFS
    debugPrintln(F("SPIFFS: mounting SPIFFS"));

#ifdef ESP8266
    if (SPIFFS.begin()) {
#endif
#ifdef ESP32
    if (SPIFFS.begin(true)) {
#endif
        if (SPIFFS.exists("/config.json")) { // File exists, reading and loading
            debugPrintln(F("SPIFFS: reading /config.json"));

            File configFile = SPIFFS.open("/config.json", "r");
            if (configFile) {
                size_t configFileSize = configFile.size(); // Allocate a buffer to store contents of the file.
                std::unique_ptr<char[]> buf(new char[configFileSize]);
                configFile.readBytes(buf.get(), configFileSize);

                DynamicJsonDocument configJson(CONFIG_SIZE);
                DeserializationError jsonError = deserializeJson(configJson, buf.get());

                if (jsonError) { // Couldn't parse the saved config
                    bool removedJson = SPIFFS.remove("/config.json");

                    debugPrintln(String(F("SPIFFS: [ERROR] Failed to parse /config.json: ")) + String(jsonError.c_str()));

                    if (removedJson) {
                        debugPrintln(String(F("SPIFFS: Removed corrupt file /config.json")));
                    }
                    else {
                        debugPrintln(String(F("SPIFFS: [ERROR] Corrupt file /config.json could not be removed")));

                    }
                }
                else {
                    // Read node configuration
                    if (!configJson["nodeName"].isNull()) {
                        strcpy(nodeName, configJson["nodeName"]);
                    }
                    else {
                        strcpy(nodeName, configJson["nodeName"]);
                    }
                    if (!configJson["configUser"].isNull()) {
                        strcpy(configUser, configJson["configUser"]);
                    }
                    if (!configJson["configPassword"].isNull()) {
                        strcpy(configPassword, configJson["configPassword"]);
                    }

                    // Read MQTT configuration
                    if (!configJson["mqttServer"].isNull()) {
                        strcpy(mqttServer, configJson["mqttServer"]);
                    }
                    if (!configJson["mqttPort"].isNull()) {
                        mqttPort = configJson["mqttPort"];
                    }
                    if (!configJson["mqttUser"].isNull()) {
                        strcpy(mqttUser, configJson["mqttUser"]);
                    }
                    if (!configJson["mqttPassword"].isNull()) {
                        strcpy(mqttPassword, configJson["mqttPassword"]);
                    }
                    if (!configJson["mqttTopic"].isNull()) {
                        strcpy(mqttTopic, configJson["mqttTopic"]);
                    }

                    // Read Debug configuration
                    if (!configJson["debugSerialEnabled"].isNull()) {
                        debugSerialEnabled = configJson["debugSerialEnabled"];
                    }
                    if (!configJson["debugRemoteEnabled"].isNull()) {
                        debugRemoteEnabled = configJson["debugRemoteEnabled"];
                    }

                    // Print read JSON configuration
                    String configJsonStr;
                    serializeJson(configJson, configJsonStr);

                    debugPrintln(String(F("SPIFFS: parsed json:")) + configJsonStr);
                }
            }
            else {
                debugPrintln(F("SPIFFS: [ERROR] File not found /config.json"));
            }
        }
        else {
            debugPrintln(F("SPIFFS: [WARNING] /config.json not found, will be created on first config save"));
        }
    }
    else {
        debugPrintln(F("SPIFFS: [ERROR] Failed to mount FS"));
    }
}

void configSave() { // Save the parameters to config.json
    debugPrintln(F("SPIFFS: Saving config"));
    DynamicJsonDocument jsonConfigValues(CONFIG_SIZE);

    // Save node configuration
    jsonConfigValues["nodeName"] = nodeName;
    jsonConfigValues["configUser"] = configUser;
    jsonConfigValues["configPassword"] = configPassword;

    // Save MQTT configuration
    jsonConfigValues["mqttServer"] = mqttServer;
    jsonConfigValues["mqttPort"] = mqttPort;
    jsonConfigValues["mqttUser"] = mqttUser;
    jsonConfigValues["mqttPassword"] = mqttPassword;
    jsonConfigValues["mqttTopic"] = mqttTopic;

    // Save Debug configuration
    jsonConfigValues["debugSerialEnabled"] = debugSerialEnabled;
    jsonConfigValues["debugRemoteEnabled"] = debugRemoteEnabled;

    File configFile = SPIFFS.open("/config.json", "w");
    if (!configFile) {
        debugPrintln(F("SPIFFS: Failed to open config file for writing"));
    }
    else {
        serializeJson(jsonConfigValues, configFile);
        configFile.close();

        // Print saved JSON configuration
        String configJsonStr;
        serializeJson(jsonConfigValues, configJsonStr);

        debugPrintln(String(F("SPIFFS: saved json:")) + configJsonStr);
    }

    delay(500);
}

void configClear(bool all) { // Clear out all local storage
    debugPrintln(F("RESET: Formatting SPIFFS"));

    SPIFFS.format();

    wifiResetSettings();

    EEPROM.begin(512);
    debugPrintln(F("Clearing EEPROM..."));

    for (uint16_t i = 0; i < EEPROM.length(); i++) {
        EEPROM.write(i, 0);
    }

    debugPrintln(F("RESET: Rebooting device"));
    nodeReset();
}

//***** WiFi Functions ****//
void wifiResetSettings() {
    debugPrintln(F("WIFI: Clearing WiFi settings..."));

    WiFiManager wifiManager;
    wifiManager.resetSettings();
}

void wifiConfig(String wifiSsid, String wifiPass) {
    debugPrintln(String(F("WIFI: Changing to WiFi network")) + wifiSsid + String(F("|")) + wifiPass + String(F("...")));

    WiFi.begin(wifiSsid.c_str(), wifiPass.c_str());

    delay(1000);
}

void wifiSetup() {
    WiFiManager wifiManager;
    wifiManager.autoConnect(uniqueNodeName);
}

void wifiLoop() {
    while ((WiFi.status() != WL_CONNECTED) || (WiFi.localIP().toString() == "0.0.0.0")) {
        // Check WiFi is connected and that we have a valid IP, retry until we do.

        if (WiFi.status() == WL_CONNECTED) {
            // If we're currently connected, disconnect so we can try again
            WiFi.disconnect();
        }

        wifiSetup();
    }
}

//***** MQTT Functions *****//

void mqttSetup() {
    mqttClient.begin(mqttServer, mqttPort, mqttWifiClient);
    mqttConnect();
}

void mqttConnect() {
    // Connect initially or reconnect if connection was lost
    if (!mqttClient.connected()) {
        bool retry = false;

        //check for retry delay
        if (mqttRetryMillis > 0) {
            unsigned long millisPassed = millis() - mqttRetryMillis;
            retry = (millisPassed >= MQTT_RETRY_DELAY);
        }
        else {
            retry = true;
        }

        if (retry) {
            // Set keepAlive, cleanSession, timeout
            mqttClient.setOptions(30, true, 1000);

            mqttClient.connect(uniqueNodeName, mqttUser, mqttPassword);
            if (mqttClient.connected()) {
                mqttRetryMillis = 0;
                mqttAvailableMsgPending = true;

                debugPrintln(String(F("MQTT: Connection established to ")) + String(mqttServer));
            }
            else {
                mqttRetryMillis = millis();

                debugPrintln(String(F("MQTT: Connection could not be established - failed with rc ")) + String(mqttClient.returnCode()));
            }
        }
    }
}

String mqttGetDefaultTopic() {
    String topic = mqttDefaultTopicBase + String(uniqueNodeName);
    return topic;
}

String mqttGetNodeTopic(String subTopic) {
    String topic = mqttTopic;

    if (topic.isEmpty()) {
        topic = mqttGetDefaultTopic();
    }

    if (!subTopic.isEmpty()) {
        if (!subTopic.startsWith(F("/"))) {
            topic += F("/");
        }

        topic += subTopic;
    }

    return topic;
}

bool mqttSend(String topic, String cmd) {
    return mqttClient.publish(topic, cmd);
}

bool mqttSendAvailable(bool reset) {
    if (reset) {
        debugPrintln(String(F("MQTT: Preparing reset, sending available --> false.")) + String(mqttServer));

        return mqttSend(mqttGetNodeTopic(mqttAvailableSubTopic), String(F("false")));
    }

    if (mqttAvailableMsgPending) {
        debugPrintln(String(F("MQTT: Sending pending available state --> true.")));

        mqttAvailableMsgPending = !mqttSend(mqttGetNodeTopic(mqttAvailableSubTopic), String(F("true")));

#ifdef MULTI_SENSOR_MODE
        debugPrintln(String(F("MQTT: Sending limit & hold time for multi-sensor/smoke detector.")));

        mqttAvailableMsgPending = !mqttSend(mqttGetNodeTopic(String(F("smoke/limit"))), String(multiMqSmokeLimit));
        mqttAvailableMsgPending = !mqttSend(mqttGetNodeTopic(String(F("smoke/holdtime"))), String(multiMqSmokeHoldTime));

        debugPrintln(String(F("MQTT: Sending hold time for multi-sensor/motion detector.")));

        mqttAvailableMsgPending = !mqttSend(mqttGetNodeTopic(String(F("motion/holdtime"))), String(multiMotionHoldTime));
#endif

        return true;
    }
    else {
        return false;
    }

    return true;
}

void mqttSendAvailableResend() {
    mqttAvailableMsgPending = true;
}

void mqttLoop() {
    mqttConnect();
    mqttSendAvailable(false);

    mqttClient.loop();
}

//***** WebServer Functions *****//
void webSetup() {
// Connect with http update server
    if ((configPassword[0] != '\0') && (configUser[0] != '\0')) {
        webUpdateServer.setup(&webServer, String(F("/updateFw")), String(configUser), String(configPassword));
    }
    else { // or without a password if not
        webUpdateServer.setup(&webServer, String(F("/updateFw")));
    }

// Setup webserver
    webServer.on("/", webHandleRoot);
    webServer.on("/settings", webHandleSettings);
    webServer.on("/saveSettings", webHandleSaveSettings);
    webServer.on("/status", webHandleStatus);

#ifdef BUTTON_MODE
    webServer.on("/buttons", webHandleButtons);
    webServer.on("/saveButtons", webHandleSaveButtons);
#endif

#ifdef RFID_MODE
    webServer.on("/rfid", webHandleRfid);
#endif

#ifdef MULTI_SENSOR_MODE
    webServer.on("/multi", webHandleMultiSensor);
    webServer.on("/saveMulti", webHandleMultiSensorSave);
#endif

    webServer.onNotFound(webHandleNotFound);
    webServer.begin();

    debugPrintln(String(F("HTTP: Server started @ http://")) + WiFi.localIP().toString());
}

void webCheckAuth() {
    if (configPassword[0] != '\0') {
        //Request HTTP auth if configPassword is set

        if (!webServer.authenticate(configUser, configPassword)) {
            return webServer.requestAuthentication();
        }
    }
}

void webStartHttpMsg(String type, int code) {
    webStartHttpMsg(type, String(F("")), code, String(F("/")));
}

void webStartHttpMsg(String type, String meta, int code) {
    webStartHttpMsg(type, meta, code, String(F("/")));
}

void webStartHttpMsg(String type, String meta, int code, String redirectUrl) {
//check if auth is needed
    webCheckAuth();

// Prepare for multipart and send first part of html header
    String httpMessage = FPSTR(HTTP_HEADER);
    httpMessage.replace(String(F("{v}")), String(uniqueNodeName));

    webServer.setContentLength(CONTENT_LENGTH_UNKNOWN);
    webServer.send(code, String(F("text/html")), httpMessage);

// Send script, style and meta
    webSendHttpContent(FPSTR(HTTP_SCRIPT));
    webSendHttpContent(FPSTR(HTTP_STYLE));

    if (meta.length() > 0) {
        meta.replace(HTML_REPLACE_REDIRURL, redirectUrl);
        webSendHttpContent(meta);
    }

// Send end of html header and start of html body
    webSendHttpContent(FPSTR(HTTP_HEADER_END));

// Send common content header
    webSendHttpContent(String(F("<h1>")));
    webSendHttpContent(String(uniqueNodeName));
    webSendHttpContent(String(F("</h1>")));

    if (type.length() > 0) {
        webSendHttpContent(String(F("<h2>")));
        webSendHttpContent(String(type));
        webSendHttpContent(String(F("</h2>")));
    }
}

void webSendHttpContent(String content, String find, String replace) {
    content.replace(find, replace);
    webSendHttpContent(content);
}

void webSendHttpContent(String content) {
    webServer.sendContent(content);
}

void webEndHttpMsg() {
// Send end of html body
    webServer.sendContent(FPSTR(HTTP_END));

    webServer.sendContent("");
    webServer.setContentLength(CONTENT_LENGTH_NOT_SET);
}

void webHandleRoot() {
    debugPrintln(String(F("HTTP: WebHandleRoot called from client: ")) + webServer.client().remoteIP().toString());

    webStartHttpMsg(String(F("Navigation")), 200);

    webSendHttpContent(HTML_ROOT_SETTINGS);

#ifdef BUTTON_MODE
    webSendHttpContent(HTML_ROOT_BUTTONS);
#endif

#ifdef RFID_MODE
    webSendHttpContent(HTML_ROOT_RFID);
#endif

#ifdef MULTI_SENSOR_MODE
    webSendHttpContent(HTML_ROOT_MULTI);
#endif

    webSendHttpContent(HTML_ROOT_STATUS);

    webEndHttpMsg();

    debugPrintln(String(F("HTTP: WebHandleRoot page sent.")));
}

void webHandleSettings() {
    debugPrintln(String(F("HTTP: WebHandleSettings called from client: ")) + webServer.client().remoteIP().toString());

    webStartHttpMsg(String(F("Settings")), 200);

    String httpMessage = "";
    webSendHttpContent(HTML_SETTINGS_FORM_START);

    webSendHttpContent(HTML_SETTINGS_NODE_NAME, String(F("{nodeName}")), nodeName);

    webSendHttpContent(HTML_SETTINGS_WIFI_SSID, String(F("{wifiSsid}")), String(WiFi.SSID()));
    webSendHttpContent(HTML_SETTINGS_WIFI_PASSWD, String(F("{wifiSsid}")), MASKED_PASSWORD);

    webSendHttpContent(HTML_SETTINGS_ADMIN_USER, String(F("{configUser}")), String(configUser));
    webSendHttpContent(HTML_SETTINGS_ADMIN_PASSWD, String(F("{configPassword}")), (strlen(configPassword) != 0) ? MASKED_PASSWORD : String(F("")));

    webSendHttpContent(HTML_SETTINGS_MQTT_SERVER, String(F("{mqttServer}")), String(mqttServer));
    webSendHttpContent(HTML_SETTINGS_MQTT_PORT, String(F("{mqttPort}")), String(mqttPort));
    webSendHttpContent(HTML_SETTINGS_MQTT_USER, String(F("{mqttUser}")), String(mqttUser));
    webSendHttpContent(HTML_SETTINGS_MQTT_PASSWD, String(F("{mqttPassword}")), (strlen(mqttPassword) != 0) ? MASKED_PASSWORD : String(F("")));
    webSendHttpContent(HTML_SETTINGS_MQTT_TOPIC, String(F("{mqttTopic}")), (strlen(mqttTopic) != 0) ? String(mqttTopic) : mqttGetDefaultTopic());
    webSendHttpContent(HTML_SETTINGS_MQTT_STATUS, String(F("{mqttStatus}")), (mqttClient.connected()) ? String(F("connected")) : String(F("diconnected")));

    webSendHttpContent(HTML_SETTINGS_DEBUG_SERIAL, String(F("{debugSerialEnabled}")), (debugSerialEnabled ? String(F("1")) : String(F("0"))));
    webSendHttpContent(HTML_SETTINGS_DEBUG_REMOTE, String(F("{debugRemoteEnabled}")), (debugRemoteEnabled ? String(F("1")) : String(F("0"))));

    webSendHttpContent(HTML_SETTINGS_BTN_SAVE_FORM_END);
    webSendHttpContent(HTML_SETTINGS_BTN_BACK);

    webEndHttpMsg();

    debugPrintln(String(F("HTTP: WebHandleSettings page sent.")));
}

void webHandleSaveSettings() {
    debugPrintln(String(F("HTTP: WebHandleSaveSettings called from client: ")) + webServer.client().remoteIP().toString());
    debugPrintln(String(F("HTTP: Checking for changed settings...")));

    bool configShouldSave = false;
    //check if node settings have changed
    if (webServer.arg(String(F("nodeName"))) != String(nodeName)) {
        configShouldSave = true;

        String lowerNodeName = webServer.arg(String(F("nodeName")));
        lowerNodeName.toLowerCase();
        lowerNodeName.toCharArray(nodeName, 32);
    }
    if (webServer.arg(String(F("configUser"))) != String(configUser)) {
        configShouldSave = true;

        webServer.arg(String(F("configUser"))).toCharArray(configUser, 32);
    }
    if (webServer.arg(String(F("configPassword"))) != String(MASKED_PASSWORD) && webServer.arg(String(F("configPassword"))) != String(configPassword)) {
        configShouldSave = true;

        webServer.arg(String(F("configPassword"))).toCharArray(configPassword, 32);
    }

    //check if wifi settings have changed
    bool shouldSaveWifi = false;
    char wifiSsid[32] = "";
    char wifiPass[64] = "";
    if (webServer.arg(String(F("wifiSsid"))) != String(WiFi.SSID())) {
        shouldSaveWifi = true;

        webServer.arg(String(F("wifiSsid"))).toCharArray(wifiSsid, 32);

        if (webServer.arg(String(F("wifiPass"))) != String(MASKED_PASSWORD) && webServer.arg(String(F("mqttPassword"))) != String(wifiPass)) {
            webServer.arg(String(F("wifiPass"))).toCharArray(wifiPass, 64);
        }
    }

    //check if mqtt settings have changed
    if (webServer.arg(String(F("mqttServer"))) != String(mqttServer)) {
        configShouldSave = true;

        webServer.arg(String(F("mqttServer"))).toCharArray(mqttServer, 64);
    }
    if (webServer.arg(String(F("mqttPort"))) != String(mqttPort)) {
        configShouldSave = true;

        mqttPort = atoi(webServer.arg(String(F("mqttPort"))).c_str());
    }
    if (webServer.arg(String(F("mqttUser"))) != String(mqttUser)) {
        configShouldSave = true;

        webServer.arg(String(F("mqttUser"))).toCharArray(mqttUser, 32);
    }
    if (webServer.arg(String(F("mqttPassword"))) != String(MASKED_PASSWORD) && webServer.arg(String(F("mqttPassword"))) != String(mqttPassword)) {
        configShouldSave = true;

        webServer.arg(String(F("mqttPassword"))).toCharArray(mqttPassword, 32);
    }
    if (webServer.arg(String(F("mqttTopic"))) != String(mqttTopic)) {
        configShouldSave = true;

        webServer.arg(String(F("mqttTopic"))).toCharArray(mqttTopic, 128);
    }

    //check if debug settings have changed
    if (webServer.arg(String(F("debugSerialEnabled"))) != String(debugSerialEnabled)) {
        configShouldSave = true;

        debugSerialEnabled = (webServer.arg(String(F("debugSerialEnabled"))).toInt() > 0);
    }

    if (webServer.arg(String(F("debugRemoteEnabled"))) != String(debugRemoteEnabled)) {
        configShouldSave = true;

        debugRemoteEnabled = (webServer.arg(String(F("debugRemoteEnabled"))).toInt() > 0);
    }

    // Process config or wifi changes
    if (configShouldSave || shouldSaveWifi) {
        // Config updated, notify user and trigger write of configurations or wifi settings7
        debugPrintln(String(F("HTTP: Sending /saveSettings page to client connected from: ")) + webServer.client().remoteIP().toString());

        webStartHttpMsg(String(F("")), HTML_SAVESETTINGS_START_REDIR_15SEC, 200, String(F("/")));
        webSendHttpContent(HTML_SAVESETTINGS_SAVE_RESTART, HTML_REPLACE_REDIRURL, String(F("/")));
        webEndHttpMsg();

        if (configShouldSave) {
            configSave();
        }

        if (shouldSaveWifi) {
            wifiConfig(wifiSsid, wifiPass);
        }

        nodeReset();
    }
    else {
        // No change found, notify user and link back to config page
        debugPrintln(String(F("HTTP: Sending /saveSettings page to client connected from: ")) + webServer.client().remoteIP().toString());

        webStartHttpMsg(String(F("")), HTML_SAVESETTINGS_START_REDIR_3SEC, 200, String(F("/settings")));
        webSendHttpContent(HTML_SAVESETTINGS_NOCHANGE, HTML_REPLACE_REDIRURL, String(F("/settings")));
        webEndHttpMsg();
    }

    debugPrintln(String(F("HTTP: WebHandleSaveSettings page sent.")));
}

void webHandleStatus() {
    debugPrintln(String(F("HTTP: WebHandleStatus called from client: ")) + webServer.client().remoteIP().toString());

    webStartHttpMsg(String(F("Status")), 200);

    webSendHttpContent(HTML_STATUS_FW_NAME, String(F("{firmwareName}")), String(fwName));
    webSendHttpContent(HTML_STATUS_FW_VERSION, String(F("{firmwareVersion}")), String(fwVersion));
    webSendHttpContent(HTML_STATUS_FW_FORM);
    webSendHttpContent(HTML_STATUS_CPU, String(F("{cpuFreq}")), String(ESP.getCpuFreqMHz()));
    webSendHttpContent(HTML_STATUS_SKETCH_SIZE, String(F("{sketchSize}")), String(ESP.getSketchSize()));
    webSendHttpContent(HTML_STATUS_SKETCH_FREESIZE, String(F("{freeSketchSize}")), String(ESP.getFreeSketchSpace()));
    webSendHttpContent(HTML_STATUS_HEAP, String(F("{freeHeap}")), String(ESP.getFreeHeap()));
    webSendHttpContent(HTML_STATUS_IPADDR, String(F("{ipAddr}")), String(WiFi.localIP().toString()));
    webSendHttpContent(HTML_STATUS_SIGSTRENGTH, String(F("{sigStrength}")), String(WiFi.RSSI()));
    unsigned long uptime = (millis() / 1000);
    webSendHttpContent(HTML_STATUS_UPTIME, String(F("{uptime}")), String(uptime));
    webSendHttpContent(HTML_STATUS_BTN_BACK);

    webEndHttpMsg();

    debugPrintln(String(F("HTTP: WebHandleStatus page sent.")));
}

void webHandleNotFound() {
    debugPrintln(String(F("HTTP: WebHandleNotFound called from client: ")) + webServer.client().remoteIP().toString());

    webStartHttpMsg(String(F("File Not Found\n\n")), 404);
    webSendHttpContent(String(F("URI: ")));
    webSendHttpContent(webServer.uri());
    webSendHttpContent(String(F("\nMethod: ")));
    webSendHttpContent((webServer.method() == HTTP_GET) ? String(F("GET")) : String(F("POST")));
    webSendHttpContent(String(F("\nArguments: ")));
    webSendHttpContent(String(webServer.args()));
    webSendHttpContent(String(F("\n")));

    for (uint8_t i = 0; i < webServer.args(); i++) {
        webSendHttpContent(" " + webServer.argName(i) + ": " + webServer.arg(i) + "\n");
    }

    webEndHttpMsg();

    debugPrintln(String(F("HTTP: WebHandleNotFound page sent.")));
}

void webLoop() {
    webServer.handleClient();
}

//***** BUTTON Functions *****//
#ifdef BUTTON_MODE
void btnSetup() {
    // Load button config if available
    btnConfigRead();

    for (int btnIndex = 0; btnIndex < NUM_OF_BUTTONS; btnIndex++) {
        btnArray[btnIndex] = new OneButton(btnPins[btnIndex], false, false);

        btnArray[btnIndex]->attachClick(btnSingleClick, &btnId[btnIndex]);
        btnArray[btnIndex]->attachDoubleClick(btnDoubleClick, &btnId[btnIndex]);
        btnArray[btnIndex]->attachMultiClick(btnMultiClick, &btnId[btnIndex]);

        btnArray[btnIndex]->attachLongPressStart(btnLongPressStart, &btnId[btnIndex]);
    }

    delay(1000);        // wait for pins to set down
}

String btnSplitMqttCmd(String data, bool command) {
    int delimiter = data.indexOf(BTN_CMD_SEPERATOR);

    if (delimiter > 0) {
        if (!command) {
            return data.substring(0, delimiter);
        }
        else {
            return data.substring(delimiter + 1);
        }
    }

    return "";
}

void btnSingleClick(void *btnIndex) {
    debugPrintln(String(F("BTN: Button ")) + *(int*) btnIndex + String(F(" single click.")));

    int index = *(int*) btnIndex;
    String mqttCmd = btnGetMqttCmd(index, BTN_TYPE_SINGLE, true);

    String topic = btnSplitMqttCmd(mqttCmd, false);
    String cmd = btnSplitMqttCmd(mqttCmd, true);

    if (!topic.isEmpty() && !cmd.isEmpty()) {
        mqttClient.publish(topic, cmd);
        debugPrintln(String(F("** BTN: Send MQTT[Topic|Cmd] ")) + topic + String(F("|")) + cmd);
    }
    else {
        debugPrintln(String(F("** BTN: No MQTT[Topic|Cmd] for singleclick defined [")) + mqttCmd + String(F("]")));
    }
}

void btnDoubleClick(void *btnIndex) {
    debugPrintln(String(F("BTN: Button ")) + *(int*) btnIndex + String(F(" double click.")));

    int index = *(int*) btnIndex;
    String mqttCmd = btnGetMqttCmd(index, BTN_TYPE_DOUBLE, true);

    String topic = btnSplitMqttCmd(mqttCmd, false);
    String cmd = btnSplitMqttCmd(mqttCmd, true);

    if (!topic.isEmpty() && !cmd.isEmpty()) {
        mqttClient.publish(topic, cmd);
        debugPrintln(String(F("** BTN: Send MQTT[Topic|Cmd] ")) + topic + String(F("|")) + cmd);
    }
    else {
        debugPrintln(String(F("** BTN: No MQTT[Topic|Cmd] for doubleclick defined [")) + mqttCmd + String(F("]")));
    }
}

void btnMultiClick(void *btnIndex) {
    debugPrintln(String(F("BTN: Button ")) + *(int*) btnIndex + String(F(" multi click.")));

    int index = *(int*) btnIndex;
    String mqttCmd = btnGetMqttCmd(index, BTN_TYPE_MULTI, true);

    String topic = btnSplitMqttCmd(mqttCmd, false);
    String cmd = btnSplitMqttCmd(mqttCmd, true);

    if (!topic.isEmpty() && !cmd.isEmpty()) {
        mqttClient.publish(topic, cmd);
        debugPrintln(String(F("** BTN: Send MQTT[Topic|Cmd] ")) + topic + String(F("|")) + cmd);
    }
    else {
        debugPrintln(String(F("** BTN: No MQTT[Topic|Cmd] for multiclick defined [")) + mqttCmd + String(F("]")));
    }
}

void btnLongPressStart(void *btnIndex) {
    debugPrintln(String(F("BTN: Button ")) + *(int*) btnIndex + String(F(" long click.")));

    int index = *(int*) btnIndex;
    String mqttCmd = btnGetMqttCmd(index, BTN_TYPE_LONG, true);

    String topic = btnSplitMqttCmd(mqttCmd, false);
    String cmd = btnSplitMqttCmd(mqttCmd, true);

    if (!topic.isEmpty() && !cmd.isEmpty()) {
        mqttClient.publish(topic, cmd);
        debugPrintln(String(F("** BTN: Send MQTT[Topic|Cmd] ")) + topic + String(F("|")) + cmd);
    }
    else {
        debugPrintln(String(F("** BTN: No MQTT[Topic|Cmd] for longclick defined [")) + mqttCmd + String(F("]")));
    }
}

void btnLoop() {
    btnArray[currentButtonIndex]->tick();

    currentButtonIndex++;

    if (currentButtonIndex >= NUM_OF_BUTTONS) {
        currentButtonIndex = 0;
    }

    for (int index = 0; index < NUM_OF_BUTTONS; index++) {
        btnArray[index]->tick();
    }
}

String btnGetCmdTypeId(int index, int type) {
    switch (type) {
    case BTN_TYPE_SINGLE:
        return BTN_CMD_1X;
    case BTN_TYPE_DOUBLE:
        return BTN_CMD_2X;
    case BTN_TYPE_MULTI:
        return BTN_CMD_MU;
    case BTN_TYPE_LONG:
        return BTN_CMD_LO;
    }

    return String(F("CmdTypeUnknown"));
}

String btnGetConfigId(int index, int type) {
    String configId = btnName[index];
    configId += btnGetCmdTypeId(index, type);

    return configId;
}

String btnGetMqttCmd(int index, int type, bool defaultIfEmpty) {
    String mqttCmd = "";

    switch (type) {
    case BTN_TYPE_SINGLE:
        mqttCmd = btnMqttCmdSingle[index];
        break;
    case BTN_TYPE_DOUBLE:
        mqttCmd = btnMqttCmdDouble[index];
        break;
    case BTN_TYPE_MULTI:
        mqttCmd = btnMqttCmdMulti[index];
        break;
    case BTN_TYPE_LONG:
        mqttCmd = btnMqttCmdLong[index];
        break;
    }

    if (defaultIfEmpty && mqttCmd.isEmpty()) {
        mqttCmd = btnGetDefaultMqttCmd(index, type);
    }

    return mqttCmd;
}

String btnGetDefaultMqttCmd(int index, int type) {
    String mqttCmd = mqttGetNodeTopic(btnName[index]);
    mqttCmd += BTN_CMD_SEPERATOR + btnGetCmdTypeId(index, type);

    return mqttCmd;
}

String btnGetBtnHtmlMqttCmd(int index, int type) {
    String btnConfigId = btnGetConfigId(index, type);

    String htmlMsg = HTML_BUTTONS_CMD_MQTT;
    htmlMsg.replace(String(F("{btnCfgId}")), btnConfigId);
    htmlMsg.replace(String(F("{btnDefaultCmd}")), btnGetDefaultMqttCmd(index, type));
    htmlMsg.replace(String(F("{btnCmd}")), btnGetMqttCmd(index, type, false));

    return htmlMsg;
}

void btnConfigRead() {
    // Read saved multiConfig.json from SPIFFS
    debugPrintln(F("SPIFFS: mounting SPIFFS"));

#ifdef ESP8266
    if (SPIFFS.begin()) {
#endif
#ifdef ESP32
    if (SPIFFS.begin(true)) {
#endif
        if (SPIFFS.exists("/buttonConfig.json")) { // File exists, reading and loading
            debugPrintln(F("SPIFFS: reading /buttonConfig.json"));

            File configFile = SPIFFS.open("/buttonConfig.json", "r");
            if (configFile) {
                size_t configFileSize = configFile.size(); // Allocate a buffer to store contents of the file.
                std::unique_ptr<char[]> buf(new char[configFileSize]);
                configFile.readBytes(buf.get(), configFileSize);

                DynamicJsonDocument configJson(CONFIG_SIZE);
                DeserializationError jsonError = deserializeJson(configJson, buf.get());

                if (jsonError) { // Couldn't parse the saved config
                    bool removedJson = SPIFFS.remove("/buttonConfig.json");

                    debugPrintln(String(F("SPIFFS: [ERROR] Failed to parse /buttonConfig.json: ")) + String(jsonError.c_str()));

                    if (removedJson) {
                        debugPrintln(String(F("SPIFFS: Removed corrupt file /buttonConfig.json")));
                    }
                    else {
                        debugPrintln(String(F("SPIFFS: [ERROR] Corrupt file /buttonConfig.json could not be removed")));

                    }
                }
                else {
                    // Read Button configuration
                    for (int index = 0; index < NUM_OF_BUTTONS; index++) {
                        strcpy(btnMqttCmdSingle[index], configJson[btnGetConfigId(index, BTN_TYPE_SINGLE)]);
                        strcpy(btnMqttCmdDouble[index], configJson[btnGetConfigId(index, BTN_TYPE_DOUBLE)]);
                        strcpy(btnMqttCmdMulti[index], configJson[btnGetConfigId(index, BTN_TYPE_MULTI)]);
                        strcpy(btnMqttCmdLong[index], configJson[btnGetConfigId(index, BTN_TYPE_LONG)]);
                    }

                    // Print read JSON configuration
                    String configJsonStr;
                    serializeJson(configJson, configJsonStr);

                    debugPrintln(String(F("SPIFFS: parsed json:")) + configJsonStr);
                }
            }
            else {
                debugPrintln(F("SPIFFS: [ERROR] File not found /buttonConfig.json"));
            }
        }
        else {
            debugPrintln(F("SPIFFS: [WARNING] /buttonConfig.json not found, will be created on first config save"));
        }
    }
    else {
        debugPrintln(F("SPIFFS: [ERROR] Failed to mount FS"));
    }
}

void btnConfigSave() { // Save the parameters to config.json
    debugPrintln(F("SPIFFS: Saving button config"));
    DynamicJsonDocument jsonConfigValues(CONFIG_SIZE);

    // Save button configuration
    for (int index = 0; index < NUM_OF_BUTTONS; index++) {
        jsonConfigValues[btnGetConfigId(index, BTN_TYPE_SINGLE)] = btnMqttCmdSingle[index];
        jsonConfigValues[btnGetConfigId(index, BTN_TYPE_DOUBLE)] = btnMqttCmdDouble[index];
        jsonConfigValues[btnGetConfigId(index, BTN_TYPE_MULTI)] = btnMqttCmdMulti[index];
        jsonConfigValues[btnGetConfigId(index, BTN_TYPE_LONG)] = btnMqttCmdLong[index];
    }

    File configFile = SPIFFS.open("/buttonConfig.json", "w");
    if (!configFile) {
        debugPrintln(F("SPIFFS: Failed to open config file for writing"));
    }
    else {
        serializeJson(jsonConfigValues, configFile);
        configFile.close();

        // Print saved JSON configuration
        String configJsonStr;
        serializeJson(jsonConfigValues, configJsonStr);
        debugPrintln(String(F("SPIFFS: saved json:")) + configJsonStr);
    }

    delay(500);
}

void webHandleButtons() {
    debugPrintln(String(F("HTTP: WebHandleButtons called from client: ")) + webServer.client().remoteIP().toString());

    webStartHttpMsg(String(F("Buttons")), 200);
    webSendHttpContent(HTML_BUTTONS_FORM_START);

    String configButtonId;
    for (int index = 0; index < NUM_OF_BUTTONS; index++) {
        // Prepare and send a html part for each button
        webSendHttpContent(HTML_BUTTONS_SECTION_START, String(F("{buttonName}")), btnName[index]);

        webSendHttpContent(HTML_BUTTONS_CMD_1X);
        webSendHttpContent(btnGetBtnHtmlMqttCmd(index, BTN_TYPE_SINGLE));

        webSendHttpContent(HTML_BUTTONS_CMD_2X);
        webSendHttpContent(btnGetBtnHtmlMqttCmd(index, BTN_TYPE_DOUBLE));

        webSendHttpContent(HTML_BUTTONS_CMD_MULTI);
        webSendHttpContent(btnGetBtnHtmlMqttCmd(index, BTN_TYPE_MULTI));

        webSendHttpContent(HTML_BUTTONS_CMD_LONG);
        webSendHttpContent(btnGetBtnHtmlMqttCmd(index, BTN_TYPE_LONG));
    }

    webSendHttpContent(HTML_BUTTONS_FORM_END);
    webSendHttpContent(HTML_BUTTONS_BTN_BACK);

    webEndHttpMsg();
}

void webHandleSaveButtons() {
    debugPrintln(String(F("HTTP: WebHandleSaveButtons called from client: ")) + webServer.client().remoteIP().toString());

//check if button settings have changed
    String data = "";
    for (int index = 0; index < NUM_OF_BUTTONS; index++) {

        data = webServer.arg(btnGetConfigId(index, BTN_TYPE_SINGLE));
        data.trim();
        strcpy(btnMqttCmdSingle[index], data.c_str());

        data = webServer.arg(btnGetConfigId(index, BTN_TYPE_DOUBLE));
        data.trim();
        strcpy(btnMqttCmdDouble[index], data.c_str());

        data = webServer.arg(btnGetConfigId(index, BTN_TYPE_MULTI));
        data.trim();
        strcpy(btnMqttCmdMulti[index], data.c_str());

        data = webServer.arg(btnGetConfigId(index, BTN_TYPE_LONG));
        data.trim();
        strcpy(btnMqttCmdLong[index], data.c_str());
    }

    // Config updated, notify user and trigger write of configurations
    debugPrintln(String(F("HTTP: Sending /saveButtons page to client connected from: ")) + webServer.client().remoteIP().toString());
    webStartHttpMsg(String(F("")), HTML_SAVESETTINGS_START_REDIR_15SEC, 200, String(F("/buttons")));
    webSendHttpContent(HTML_SAVESETTINGS_SAVE_NORESTART, HTML_REPLACE_REDIRURL, String(F("/buttons")));
    webEndHttpMsg();

    btnConfigSave();
}
#endif

//***** RFID Functions *****//
#ifdef RFID_MODE

void rfidSetup() {
    SPI.begin(); // Init SPI bus
    rfid.PCD_Init(); // Init MFRC522
    delay(100);

    rfidInitNuid();

    //check rfid connection and firmware version
    debugPrintln(String(F("RFID: Connecting rfid controller...")));

    rfidControllerData = "";

    byte version = rfid.PCD_ReadRegister(MFRC522::PCD_Register::VersionReg);
    rfidControllerData = "Firmware Version: " + String(version, HEX);

    // When 0x00 or 0xFF is returned, communication probably failed
    if ((version == 0x00) || (version == 0xFF)) {
        rfidControllerData = String(F("Communication failure, is the MFRC522 properly connected?"));

        debugPrintln(String(F("RFID: ")) + rfidControllerData);
    }
    else {
        debugPrintln(String(F("RFID: Connected rfid controller - ")) + rfidControllerData);
    }
}

void rfidInitNuid() {
    //initialize key
    for (byte i = 0; i < 4; i++) {
        rfidNuidPICC[i] = 0xFF;
    }
}

void rfidLoop() {
    // Send pending mqtt message
    if (rfidCardPending) {
        rfidCardPending = !mqttSend(mqttGetNodeTopic(String(F("rfid-uid"))), rfidNuidString);
    }

    // Throttle control for spi read
    if (rfidLastReadMillis != 0) {
        unsigned long millisPassed = millis() - rfidLastReadMillis;
        if (millisPassed < RFID_CARD_READ_TIMEOUT) {
            return;
        }
        else {
            rfidLastReadMillis = 0;
            rfidInitNuid();
            rfidNuidString = "0";
            rfidCardPending = true;
        }
    }

    // Reset the loop if no new card present on the sensor/reader. This saves the entire process when idle.
    if (!rfid.PICC_IsNewCardPresent())
        return;
    // Verify if the NUID has been readed
    if (!rfid.PICC_ReadCardSerial())
        return;

    debugPrint(F("RFID: PICC type - "));
    MFRC522::PICC_Type piccType = rfid.PICC_GetType(rfid.uid.sak);
    debugPrintln(rfid.PICC_GetTypeName(piccType));

    // Check is the PICC of Classic MIFARE type
    if (piccType != MFRC522::PICC_TYPE_MIFARE_MINI && piccType != MFRC522::PICC_TYPE_MIFARE_1K && piccType != MFRC522::PICC_TYPE_MIFARE_4K) {
        debugPrintln(F("RFID: Your tag is not of type MIFARE Classic."));
        return;
    }
    if (rfid.uid.uidByte[0] != rfidNuidPICC[0] || rfid.uid.uidByte[1] != rfidNuidPICC[1] || rfid.uid.uidByte[2] != rfidNuidPICC[2] || rfid.uid.uidByte[3] != rfidNuidPICC[3]) {
        debugPrint(F("RFID: A new card has been detected - "));

        // Store NUID into nuidPICC array and set nuidString
        rfidNuidString = "";
        for (byte i = 0; i < 4; i++) {
            rfidNuidPICC[i] = rfid.uid.uidByte[i];
            rfidNuidString += rfid.uid.uidByte[i];
        }
        debugPrintln(rfidNuidString);

        // Trigger send rfid uid via mqtt and set timestamp
        rfidCardPending = true;
        rfidLastReadMillis = millis();
    }
    else {
        debugPrintln(F("RFID: Card read previously."));
    }

    // Halt PICC
    rfid.PICC_HaltA();
    // Stop encryption on PCD
    rfid.PCD_StopCrypto1();
}

void webHandleRfid() {
    debugPrintln(String(F("HTTP: WebHandleRfid called from client: ")) + webServer.client().remoteIP().toString());

    webStartHttpMsg(String(F("RFID")), 200);

    webSendHttpContent(HTML_RFID_STATUS, String(F("{rfidControllerData}")), rfidControllerData);
    webSendHttpContent(HTML_RFID_LASTNUID, String(F("{rfidNuidString}")), rfidNuidString);
    webSendHttpContent(HTML_RFID_BTN_BACK);

    webEndHttpMsg();

    debugPrintln(String(F("HTTP: WebHandleRfid page sent.")));
}
#endif

//***** MULTISENSOR Functions *****//
#ifdef MULTI_SENSOR_MODE

void multiSetup() {
    // Load configuration if available
    multiConfigRead();

    Wire.begin(D2, D1);
    multiAdcSensorInitialized = multiAdc.begin();

    if (!multiAdcSensorInitialized) {
        debugPrintln(String(F("MULTI: Failed to initialize ADC.")));
    }

    if (multiAdcSensorInitialized) {
        // Setup MQ2 sensor
        multiMqSensor.setRegressionMethod(1); // _PPM =  a*ratio^b
        multiMqSensor.setA(30000000); // Configure for smoke concentration
        multiMqSensor.setB(-8.308);
        multiMqSensor.init();

        multiMqSensorState = String(F("Pending: Warming up..."));
    }
    else {
        multiMqSensorState = String(F("Error: ADC initialization failed."));
    }
}

int16_t multiMqReadAdcRaw() {
    return multiAdc.readADC_SingleEnded(MULTI_ADC_MQ_PIN);
}
bool multiMqWarmUp() {
    if (multiMqWarmedUp) {
        return true;
    }

    if (multiAdcSensorInitialized && !multiMqWarmedUp) {
        unsigned long secondsPassed = 0;

        if (multiMqWarmupTimer == 0) {
            multiMqWarmupTimer = millis();

            debugPrintln(String(F("MULTI: MQ2 sensor warming up for ")) + String(MULTI_MQ2_WARMUP_SEC) + String(F(" sec...")));
        }
        else {
            secondsPassed = (millis() - multiMqWarmupTimer) / 1000;
        }

        multiMqWarmedUp = (secondsPassed >= MULTI_MQ2_WARMUP_SEC);

        if (multiMqWarmedUp) {
            debugPrintln(String(F("MULTI: MQ2 sensor warmed up.")));

            multiMqSensorState = String(F("Pending: Calibrating sensor..."));
        }
    }

    return false;
}

bool multiMqCalibrate() {
    if (multiMqCalibrated) {
        return true;
    }

    if (multiMqWarmUp() && !multiMqCalibrated) {
        debugPrintln("MULTI: MQ sensor calibrating please wait...");

        float calcR0 = 0;
        for (int i = 1; i <= 10; i++) {
            multiMqSensor.setADC(multiMqReadAdcRaw());
            calcR0 += multiMqSensor.calibrate(MULTI_MQ2_RATIO_CLEANAIR);
        }
        multiMqSensor.setR0(calcR0 / 10);

        if (isinf(calcR0)) {
            multiMqSensorState = String(F("Error: Connection issue founded, R0 is infite."));

            debugPrintln("MULTI: Warning, MQ sensor connection issue founded, R0 is infite (open circuit detected) please check your wiring and supply.");
        }
        else if (calcR0 == 0) {
            multiMqSensorState = String(F("Error: Connection issue founded, R0 i zero."));

            debugPrintln("MULTI: Warning, MQ sensor connection issue founded, R0 is zero (Analog pin with short circuit to ground) please check your wiring and supply");
        }
        else {
            multiMqCalibrated = true;
            multiMqSensorState = String(F("Ready..."));

            debugPrintln("MULTI: MQ sensor calibrated.");
        }
    }

    return false;
}

void multiMqLoop() {
    // Send pending message if needed
    if (multiMqSmokePending) {
        debugPrintln(String(F("MULTI: MQ sensor sending state ---> ")) + (multiMqSmokeDetected ? String(F("detected")) : String(F("none"))));

        multiMqSmokePending = !mqttSend(mqttGetNodeTopic(String(F("smoke"))), multiMqSmokeDetected ? String(F("detected")) : String(F("none")));
    }

    // Return if warm up and calibration are not done yet
    if (!multiMqWarmUp() && !multiMqCalibrate()) {
        return; //do not start reading if
    }

    // Read current smoke state
    multiMqSensor.setADC(multiMqReadAdcRaw());
    float smokePPM = multiMqSensor.readSensor(); // Sensor will read PPM concentration using the model and a and b values setted before or in the setup
    boolean smokeDetected = (smokePPM >= multiMqSmokeLimit);

    // Smoke was detected, evaluate timer state
    if (smokeDetected) {
        if (multiMqSmokeHoldTimer != 0) {
            // Timer was already set prior, so just set a new time value
            multiMqSmokeHoldTimer = millis();
        }
        else {
            debugPrintln(String(F("MULTI: Smoke detected --> setting timer.")));

            // Timer should be set for the first time
            multiMqSmokeHoldTimer = millis();
            // Set pending message, if timer is set for the first time and return from function
            multiMqSmokePending = true;
            multiMqSmokeDetected = smokeDetected;

            return;
        }
    }

    // Evaluate if hold time expired
    unsigned long secondsPassed = 0;
    if (multiMqSmokeHoldTimer != 0) {
        secondsPassed = (millis() - multiMqSmokeHoldTimer) / 1000;
    }

    if (secondsPassed >= multiMqSmokeHoldTime) {
        debugPrintln(String(F("MULTI: Smoke hold time expired --> setting pending message.")));

        // Set pending message, if hold time expired
        multiMqSmokePending = true;
        multiMqSmokeDetected = smokeDetected;
        // Reset timer for next detected smoke
        multiMqSmokeHoldTimer = 0;
    }
}

void multiLightLoop() {
    int16_t lightRawValue = multiAdc.readADC_SingleEnded(MULTI_ADC_LIGHT_PIN);
    multiLightVoltage = multiAdc.computeVolts(lightRawValue);

    long lightPercentage = map(multiLightVoltage, multiLightMinValue, multiLightMaxValue, 0, 100);
    lightPercentage = constrain(lightPercentage, 0, 100);

    if (lightPercentage != multiLightPercentage) {
        mqttSend(mqttGetNodeTopic(String(F("light"))), String(lightPercentage));
    }

    multiLightPercentage = lightPercentage;   // Save result and send message if value changes
}

void multiMotionLoop() {
// Send pending message if needed
    if (multiMotionPending) {
        debugPrintln(String(F("MULTI: Motion sensor sending state ---> ")) + (multiMotionDetected ? String(F("detected")) : String(F("none"))));

        multiMotionPending = !mqttSend(mqttGetNodeTopic(String(F("motion"))), multiMotionDetected ? String(F("detected")) : String(F("none")));
    }

// Read current motion state
    int16_t motionRawValue = multiAdc.readADC_SingleEnded(MULTI_ADC_MOTION_PIN);
    int16_t motionVoltage = multiAdc.computeVolts(motionRawValue);

    bool motionDetected = (motionVoltage >= 3);

// Motion was detected, evaluate timer state
    if (motionDetected) {
        if (multiMotionHoldTimer != 0) {
            // Timer was already set prior, so just set a new time value
            multiMotionHoldTimer = millis();
        }
        else {
            debugPrintln(String(F("MULTI: Motion detected --> setting timer.")));

            // Timer should be set for the first time
            multiMotionHoldTimer = millis();
            // Set pending message, if timer is set for the first time and return from function
            multiMotionPending = true;
            multiMotionDetected = motionDetected;

            return;
        }
    }

// Evaluate if hold time expired
    unsigned long secondsPassed = 0;
    if (multiMotionHoldTimer != 0) {
        secondsPassed = (millis() - multiMotionHoldTimer) / 1000;
    }

    if (secondsPassed >= multiMotionHoldTime) {
        debugPrintln(String(F("MULTI: Motion hold time expired --> setting pending message.")));

        // Set pending message, if hold time expired
        multiMotionPending = true;
        multiMotionDetected = motionDetected;
        // Reset timer for next detected motion
        multiMotionHoldTimer = 0;
    }
}

void multiLoop() {
    multiMqLoop();
    multiLightLoop();
    multiMotionLoop();
}

void multiConfigRead() {
    // Read saved multiConfig.json from SPIFFS
    debugPrintln(F("SPIFFS: mounting SPIFFS"));

#ifdef ESP8266
    if (SPIFFS.begin()) {
#endif
#ifdef ESP32
    if (SPIFFS.begin(true)) {
#endif
        if (SPIFFS.exists("/multiConfig.json")) { // File exists, reading and loading
            debugPrintln(F("SPIFFS: reading /multiConfig.json"));

            File configFile = SPIFFS.open("/multiConfig.json", "r");
            if (configFile) {
                size_t configFileSize = configFile.size(); // Allocate a buffer to store contents of the file.
                std::unique_ptr<char[]> buf(new char[configFileSize]);
                configFile.readBytes(buf.get(), configFileSize);

                DynamicJsonDocument configJson(CONFIG_SIZE);
                DeserializationError jsonError = deserializeJson(configJson, buf.get());

                if (jsonError) { // Couldn't parse the saved config
                    bool removedJson = SPIFFS.remove("/multiConfig.json");

                    debugPrintln(String(F("SPIFFS: [ERROR] Failed to parse /multiConfig.json: ")) + String(jsonError.c_str()));

                    if (removedJson) {
                        debugPrintln(String(F("SPIFFS: Removed corrupt file /multiConfig.json")));
                    }
                    else {
                        debugPrintln(String(F("SPIFFS: [ERROR] Corrupt file /multiConfig.json could not be removed")));

                    }
                }
                else {
                    // Read Multi Sensor configuration
                    if (!configJson["multiMqSmokeLimit"].isNull()) {
                        multiMqSmokeLimit = configJson["multiMqSmokeLimit"];
                    }
                    if (!configJson["multiMqSmokeHoldTime"].isNull()) {
                        multiMqSmokeHoldTime = configJson["multiMqSmokeHoldTime"];
                    }
                    if (!configJson["multiLightMinValue"].isNull()) {
                        multiLightMinValue = configJson["multiLightMinValue"];
                    }
                    if (!configJson["multiLightMaxValue"].isNull()) {
                        multiLightMaxValue = configJson["multiLightMaxValue"];
                    }
                    if (!configJson["multiMotionHoldTime"].isNull()) {
                        multiMotionHoldTime = configJson["multiMotionHoldTime"];
                    }

                    // Print read JSON configuration
                    String configJsonStr;
                    serializeJson(configJson, configJsonStr);

                    debugPrintln(String(F("SPIFFS: parsed json:")) + configJsonStr);
                }
            }
            else {
                debugPrintln(F("SPIFFS: [ERROR] File not found /multiConfig.json"));
            }
        }
        else {
            debugPrintln(F("SPIFFS: [WARNING] /multiConfig.json not found, will be created on first config save"));
        }
    }
    else {
        debugPrintln(F("SPIFFS: [ERROR] Failed to mount FS"));
    }
}

void multiConfigSave() { // Save the parameters to config.json
    debugPrintln(F("SPIFFS: Saving multisensor config"));
    DynamicJsonDocument jsonConfigValues(CONFIG_SIZE);

    // Save multi sensor configuration
    jsonConfigValues["multiMqSmokeLimit"] = multiMqSmokeLimit;
    jsonConfigValues["multiMqSmokeHoldTime"] = multiMqSmokeHoldTime;
    jsonConfigValues["multiLightMinValue"] = multiLightMinValue;
    jsonConfigValues["multiLightMaxValue"] = multiLightMaxValue;
    jsonConfigValues["multiMotionHoldTime"] = multiMotionHoldTime;

    File configFile = SPIFFS.open("/multiConfig.json", "w");
    if (!configFile) {
        debugPrintln(F("SPIFFS: Failed to open config file for writing"));
    }
    else {
        serializeJson(jsonConfigValues, configFile);
        configFile.close();

        // Print saved JSON configuration
        String configJsonStr;
        serializeJson(jsonConfigValues, configJsonStr);
        debugPrintln(String(F("SPIFFS: saved json:")) + configJsonStr);
    }

    delay(500);
}

void webHandleMultiSensor() {
    debugPrintln(String(F("HTTP: WebHandleMultiSensor called from client: ")) + webServer.client().remoteIP().toString());

    webStartHttpMsg(String(F("Multi Sensor")), 200);

    webSendHttpContent(HTML_MULTI_FORM_START);
    webSendHttpContent(HTML_MULTI_ADC_STATUS, String(F("{multiAdcSensorInitialized}")), (multiAdcSensorInitialized ? String(F("ok")) : String(F("error"))));
    webSendHttpContent(HTML_MULTI_MQ_STATUS, String(F("{multiMqSensorState}")), multiMqSensorState);

    webSendHttpContent(HTML_MULTI_MQ_SMOKE_STATUS, String(F("{multiMqSmokeDetected}")), (multiMqSmokeDetected ? String(F("detected")) : String(F("none"))));
    webSendHttpContent(HTML_MULTI_MQ_SMOKE_LIMIT, String(F("{multiMqSmokeLimit}")), String(multiMqSmokeLimit));
    webSendHttpContent(HTML_MULTI_MQ_HOLDTIME, String(F("{multiMqSmokeHoldTime}")), String(multiMqSmokeHoldTime));

    String lightSensorValue = String(multiLightVoltage) + String(F("v / ")) + String(multiLightPercentage) + String(F("%"));
    webSendHttpContent(HTML_MULTI_LIGHT_VAL, String(F("{multiLightSensorValue}")), lightSensorValue);
    webSendHttpContent(HTML_MULTI_LIGHT_MIN_VAL, String(F("{multiLightMinValue}")), String(multiLightMinValue));
    webSendHttpContent(HTML_MULTI_LIGHT_MAX_VAL, String(F("{multiLightMaxValue}")), String(multiLightMaxValue));

    webSendHttpContent(HTML_MULTI_MOTION_VAL, String(F("{multiMotionDetected}")), (multiMotionDetected ? String(F("detected")) : String(F("none"))));
    webSendHttpContent(HTML_MULTI_MOTION_HOLDTIME, String(F("{multiMotionHoldTime}")), String(multiMotionHoldTime));

    webSendHttpContent(HTML_MULTI_BTN_SAVE_FORM_END);
    webSendHttpContent(HTML_MULTI_BTN_BACK);

    webEndHttpMsg();

    debugPrintln(String(F("HTTP: WebHandleMultiSensor page sent.")));
}

void webHandleMultiSensorSave() {
    debugPrintln(String(F("HTTP: webHandleMultiSensorSave called from client: ")) + webServer.client().remoteIP().toString());
    debugPrintln(String(F("HTTP: Checking for changed settings...")));

    bool configShouldSave = false;
    //check if multi sensor settings have changed
    if (webServer.arg(String(F("multiMqSmokeLimit"))) != String(multiMqSmokeLimit)) {
        configShouldSave = true;

        multiMqSmokeLimit = atoi(webServer.arg(String(F("multiMqSmokeLimit"))).c_str());
    }
    if (webServer.arg(String(F("multiMqSmokeHoldTime"))) != String(multiMqSmokeHoldTime)) {
        configShouldSave = true;

        multiMqSmokeHoldTime = atoi(webServer.arg(String(F("multiMqSmokeHoldTime"))).c_str());
    }
    if (webServer.arg(String(F("multiLightMinValue"))) != String(multiLightMinValue)) {
        configShouldSave = true;

        multiLightMinValue = atoi(webServer.arg(String(F("multiLightMinValue"))).c_str());
    }
    if (webServer.arg(String(F("multiLightMaxValue"))) != String(multiLightMaxValue)) {
        configShouldSave = true;

        multiLightMaxValue = atoi(webServer.arg(String(F("multiLightMaxValue"))).c_str());
    }
    if (webServer.arg(String(F("multiMotionHoldTime"))) != String(multiMotionHoldTime)) {
        configShouldSave = true;

        multiMotionHoldTime = atoi(webServer.arg(String(F("multiMotionHoldTime"))).c_str());
    }

// Process config or wifi changes
    if (configShouldSave) {
        // Config updated, notify user and trigger write of configurations or wifi settings
        debugPrintln(String(F("HTTP: Sending /saveMulti page to client connected from: ")) + webServer.client().remoteIP().toString());

        webStartHttpMsg(String(F("")), HTML_SAVESETTINGS_START_REDIR_15SEC, 200, String(F("/multi")));
        webSendHttpContent(HTML_SAVESETTINGS_SAVE_NORESTART, HTML_REPLACE_REDIRURL, String(F("/multi")));
        webEndHttpMsg();

        if (configShouldSave) {
            multiConfigSave();
            mqttSendAvailableResend();
        }
    }
    else {
        // No change found, notify user and link back to config page
        debugPrintln(String(F("HTTP: Sending /saveMulti page to client connected from: ")) + webServer.client().remoteIP().toString());

        webStartHttpMsg(String(F("")), HTML_SAVESETTINGS_START_REDIR_3SEC, 200, String(F("/multi")));
        webSendHttpContent(HTML_SAVESETTINGS_NOCHANGE, HTML_REPLACE_REDIRURL, String(F("/multi")));
        webEndHttpMsg();
    }

    debugPrintln(String(F("HTTP: webHandleMultiSensorSave page sent.")));
}
#endif
